<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>多线程_JUC锁集合 | 兼一书虫</title><meta name="keywords" content="server,frontend,backend,hexo"><meta name="author" content="narutohyc"><meta name="copyright" content="narutohyc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JUC锁集合同步锁: 即通过synchronized关键字来进行同步，实现对竞争资源的互斥访问的锁。Java 1.0版本中就已经支持同步锁了。对于每一个对象，有且仅有一个同步锁；不同的线程能共同访问该同步锁。但是，在同一个时间点，该同步锁能且只能被一个线程获取到。这样，获取到同步锁的线程就能进行CPU调度，从而在CPU上执行；而没有获取到同步锁的线程，必须进行等待，直到获取到同步锁之后才能继续运">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程_JUC锁集合">
<meta property="og:url" content="https://study.hycbook.com/article/10fd680e.html">
<meta property="og:site_name" content="兼一书虫">
<meta property="og:description" content="JUC锁集合同步锁: 即通过synchronized关键字来进行同步，实现对竞争资源的互斥访问的锁。Java 1.0版本中就已经支持同步锁了。对于每一个对象，有且仅有一个同步锁；不同的线程能共同访问该同步锁。但是，在同一个时间点，该同步锁能且只能被一个线程获取到。这样，获取到同步锁的线程就能进行CPU调度，从而在CPU上执行；而没有获取到同步锁的线程，必须进行等待，直到获取到同步锁之后才能继续运">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.hycbook.com/i/hexo/post_cover/%E8%95%BE%E5%A7%867.webp">
<meta property="article:published_time" content="2022-09-10T12:46:25.000Z">
<meta property="article:modified_time" content="2023-09-06T14:53:56.122Z">
<meta property="article:author" content="narutohyc">
<meta property="article:tag" content="server,frontend,backend,hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.hycbook.com/i/hexo/post_cover/%E8%95%BE%E5%A7%867.webp"><link rel="shortcut icon" href="https://pic.hycbook.com/i//hexo/config_imgs/网站图标.webp"><link rel="canonical" href="https://study.hycbook.com/article/10fd680e"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/manifest.json"/><meta name="msapplication-TileColor" content="#c6ff7a"/><link rel="apple-touch-icon" sizes="180x180" href="https://pic.hycbook.com/i//hexo/source/img/siteicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="https://pic.hycbook.com/i//hexo/source/img/siteicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="https://pic.hycbook.com/i//hexo/source/img/siteicon/favicon-16x16.png"/><link rel="mask-icon" href="https://pic.hycbook.com/i//hexo/source/img/siteicon/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?68340394dfd808cea9826e8a57f87aa6";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":120,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: narutohyc","link":"链接: ","source":"来源: 兼一书虫","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '多线程_JUC锁集合',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-06 22:53:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/hyc_udf.css"><link rel="stylesheet" href="/css/udf_css.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/mainColor/heoMainColor.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/404/404.css"><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><link href="https://cdn.bootcdn.net/ajax/libs/toastr.js/2.1.4/toastr.min.css" rel="stylesheet"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.hycbook.com/i/hexo/person_img/兼一头像.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">115</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">169</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-fangwu"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wenzhang1">             </use></svg><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-guidang">                   </use></svg><span> 归档</span></a></li><li><a class="site-page child" href="/categories"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-fenlei">                   </use></svg><span> 分类</span></a></li><li><a class="site-page child" href="/tags"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-biaoqian">                   </use></svg><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wenzhang1">             </use></svg><span> gitbook版</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://common.hycbook.com"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-guidang">                   </use></svg><span> common</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://python.hycbook.com"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-fenlei">                   </use></svg><span> python</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://dl.hycbook.com"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-biaoqian">                   </use></svg><span> 深度学习</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-xuegao">             </use></svg><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-yinle">                   </use></svg><span> 音乐</span></a></li><li><a class="site-page child" href="/bangumis"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wodezhuifan">                   </use></svg><span> 追番</span></a></li><li><a class="site-page child" href="/gallery"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-xiangce">                   </use></svg><span> 相册</span></a></li><li><a class="site-page child" href="/video"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-shipin">                   </use></svg><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/charts"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-xigua"></use></svg><span> 统计图</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-suannai">             </use></svg><span> 网盘</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://pan.hycbook.com"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-guidang">                   </use></svg><span> 私月盘</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://share.hycbook.com"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhifengche">                   </use></svg><span> 共享盘</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhifeiji">             </use></svg><span> 导航</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/comments"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-TIFFANYSROOM_huaban">                   </use></svg><span> 留言板</span></a></li><li><a class="site-page child" href="/link"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-changyonglianjie">                   </use></svg><span> 友链</span></a></li><li><a class="site-page child" href="/about"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-aixin">                   </use></svg><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pic.hycbook.com/i/hexo/post_imgs/蕾姆7.webp')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">兼一书虫</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-fangwu"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wenzhang1">             </use></svg><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-guidang">                   </use></svg><span> 归档</span></a></li><li><a class="site-page child" href="/categories"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-fenlei">                   </use></svg><span> 分类</span></a></li><li><a class="site-page child" href="/tags"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-biaoqian">                   </use></svg><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wenzhang1">             </use></svg><span> gitbook版</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://common.hycbook.com"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-guidang">                   </use></svg><span> common</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://python.hycbook.com"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-fenlei">                   </use></svg><span> python</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://dl.hycbook.com"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-biaoqian">                   </use></svg><span> 深度学习</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-xuegao">             </use></svg><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-yinle">                   </use></svg><span> 音乐</span></a></li><li><a class="site-page child" href="/bangumis"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wodezhuifan">                   </use></svg><span> 追番</span></a></li><li><a class="site-page child" href="/gallery"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-xiangce">                   </use></svg><span> 相册</span></a></li><li><a class="site-page child" href="/video"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-shipin">                   </use></svg><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/charts"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-xigua"></use></svg><span> 统计图</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-suannai">             </use></svg><span> 网盘</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://pan.hycbook.com"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-guidang">                   </use></svg><span> 私月盘</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://share.hycbook.com"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhifengche">                   </use></svg><span> 共享盘</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhifeiji">             </use></svg><span> 导航</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/comments"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-TIFFANYSROOM_huaban">                   </use></svg><span> 留言板</span></a></li><li><a class="site-page child" href="/link"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-changyonglianjie">                   </use></svg><span> 友链</span></a></li><li><a class="site-page child" href="/about"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-aixin">                   </use></svg><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">多线程_JUC锁集合</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-10T12:46:25.000Z" title="发表于 2022-09-10 20:46:25">2022-09-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-06T14:53:56.122Z" title="更新于 2023-09-06 22:53:56">2023-09-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>63分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title="多线程_JUC锁集合"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/article/10fd680e.html#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr>
<h1 id="JUC锁集合"><a href="#JUC锁集合" class="headerlink" title="JUC锁集合"></a>JUC锁集合</h1><p><strong>同步锁</strong>: 即通过synchronized关键字来进行同步，实现对竞争资源的互斥访问的锁。Java 1.0版本中就已经支持同步锁了。对于每一个对象，有且仅有一个同步锁；不同的线程能共同访问该同步锁。但是，在同一个时间点，该同步锁能且只能被一个线程获取到。这样，获取到同步锁的线程就能进行CPU调度，从而在CPU上执行；而没有获取到同步锁的线程，必须进行等待，直到获取到同步锁之后才能继续运行。这就是，多线程通过同步锁进行同步的原理！ </p>
<p><strong>JUC包中的锁</strong> : 相比同步锁，JUC包中的锁的功能更加强大，它为锁提供了一个框架，该框架允许更灵活地使用锁，只是它的用法更难罢了。</p>
<p>　　JUC包中的锁，包括：Lock接口，ReadWriteLock接口，LockSupport阻塞原语，Condition条件，AbstractOwnableSynchronizer/AbstractQueuedSynchronizer/AbstractQueuedLongSynchronizer三个抽象类，ReentrantLock独占锁，ReentrantReadWriteLock读写锁。由于CountDownLatch，CyclicBarrier和Semaphore也是通过AQS来实现的；</p>
<p><strong>Lock接口</strong>: JUC包中的 Lock 接口支持那些语义不同(重入、公平等)的锁规则。所谓语义不同，是指锁可是有”公平机制的锁”、”非公平机制的锁”、”可重入的锁”等等。”公平机制”是指”不同线程获取锁的机制是公平的”，而”非公平机制”则是指”不同线程获取锁的机制是非公平的”，”可重入的锁”是指同一个锁能够被一个线程多次获取。</p>
<p> <strong>ReadWriteLock</strong>: ReadWriteLock 接口以和Lock类似的方式定义了一些读取者可以共享而写入者独占的锁。JUC包只有一个类实现了该接口，即 ReentrantReadWriteLock，因为它适用于大部分的标准用法上下文。但程序员可以创建自己的、适用于非标准要求的实现。</p>
<p> <strong>AQS</strong>: AbstractOwnableSynchronizer/AbstractQueuedSynchronizer/AbstractQueuedLongSynchronizer 　　AbstractQueuedSynchronizer就是被称之为AQS的类，它是一个非常有用的超类，可用来定义锁以及依赖于排队阻塞线程的其他同步器；ReentrantLock，ReentrantReadWriteLock，CountDownLatch，CyclicBarrier和Semaphore等这些类都是基于AQS类实现的。AbstractQueuedLongSynchronizer 类提供相同的功能但扩展了对同步状态的 64 位的支持。两者都扩展了类 AbstractOwnableSynchronizer（一个帮助记录当前保持独占同步的线程的简单类）。</p>
<p><strong>LockSupport</strong>: LockSupport提供“创建锁”和“其他同步类的基本线程阻塞原语”。<br>　　LockSupport的功能和”Thread中的Thread.suspend()和Thread.resume()有点类似”，LockSupport中的park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程。但是park()和unpark()不会遇到“Thread.suspend 和 Thread.resume所可能引发的死锁”问题。</p>
<p> <strong>Condition</strong>: Condition需要和Lock联合使用，它的作用是代替Object监视器方法，可以通过await(),signal()来休眠/唤醒线程。<br>        Condition 接口描述了可能会与锁有关联的条件变量。这些变量在用法上与使用 Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，单个 Lock 可能与多个 Condition 对象关联。为了避免兼容性问题，Condition 方法的名称与对应的 Object 版本中的不同。</p>
<p> <strong>ReentrantLock</strong>: ReentrantLock是独占锁。所谓独占锁，是指只能被独自占领，即同一个时间点只能被一个线程锁获取到的锁。ReentrantLock锁包括”公平的ReentrantLock”和”非公平的ReentrantLock”。”公平的ReentrantLock”是指”不同线程获取锁的机制是公平的”，而”非公平的　　ReentrantLock”则是指”不同线程获取锁的机制是非公平的”，ReentrantLock是”可重入的锁”。</p>
<p><strong>ReentrantReadWriteLock</strong>: ReentrantReadWriteLock是读写锁接口ReadWriteLock的实现类，它包括子类ReadLock和WriteLock。ReentrantLock是共享锁，而WriteLock是独占锁。</p>
<p><strong>CountDownLatch</strong>: CountDownLatch是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。CountDownLatch包含了sync对象，sync是Sync类型。CountDownLatch的Sync是实例类，它继承于AQS。</p>
<p><strong>CyclicBarrier</strong>: CyclicBarrier是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CyclicBarrier是包含了<span class="string">&quot;ReentrantLock对象lock&quot;</span>和<span class="string">&quot;Condition对象trip&quot;</span>，它是通过独占锁实现的。</span><br><span class="line">CyclicBarrier和CountDownLatch的区别**是：</span><br><span class="line">(<span class="number">01</span>) CountDownLatch的作用是允许<span class="number">1</span>或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待。</span><br><span class="line">(<span class="number">02</span>) CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。</span><br></pre></td></tr></table></figure>
<p><strong>Semaphore</strong>: Semaphore是一个计数信号量，它的本质是一个”共享锁”。<br>    　信号量维护了一个信号量许可集。线程可以通过调用acquire()来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须等待，直到有可用的许可为止。 线程可以通过release()来释放它所持有的信号量许可。和”ReentrantLock”一样，Semaphore包含了sync对象，sync是Sync类型；而且，Sync也是一个继承于AQS的抽象类。Sync也包括”公平信号量”FairSync和”非公平信号量”NonfairSync。</p>
<h1 id="互斥锁ReentrantLock"><a href="#互斥锁ReentrantLock" class="headerlink" title="互斥锁ReentrantLock"></a>互斥锁ReentrantLock</h1><p>ReentrantLock是一个可重入的互斥锁，又被称为“独占锁”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">顾名思义，ReentrantLock锁在同一个时间点只能被一个线程锁持有；而可重入的意思是，ReentrantLock锁，可以被单个线程多次获取。</span><br><span class="line">ReentrantLock分为“公平锁”和“非公平锁”。它们的区别体现在获取锁的机制上是否公平。“锁”是为了保护竞争资源，防止多个线程同时操作线程而出错，ReentrantLock在同一个时间点只能被一个线程获取(当某线程获取到“锁”时，其它线程就必须等待)；ReentraantLock是通过一个FIFO的等待队列来管理获取该锁所有线程的。在“公平锁”的机制下，线程依次排队获取锁；而“非公平锁”在锁是可获取状态时，不管自己是不是在队列的开头都会获取锁。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock函数列表</span></span><br><span class="line"><span class="comment">// 创建一个 ReentrantLock ，默认是“非公平锁”。</span></span><br><span class="line">ReentrantLock()</span><br><span class="line"><span class="comment">// 创建策略是fair的 ReentrantLock。fair为true表示是公平锁，fair为false表示是非公平锁。</span></span><br><span class="line">ReentrantLock(<span class="type">boolean</span> fair)</span><br><span class="line"><span class="comment">// 查询当前线程保持此锁的次数。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getHoldCount</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 返回目前拥有此锁的线程，如果此锁不被任何线程拥有，则返回 null。</span></span><br><span class="line"><span class="keyword">protected</span> Thread <span class="title function_">getOwner</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 返回一个 collection，它包含可能正等待获取此锁的线程。</span></span><br><span class="line"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title function_">getQueuedThreads</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 返回正等待获取此锁的线程估计数。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getQueueLength</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 返回一个 collection，它包含可能正在等待与此锁相关给定条件的那些线程。</span></span><br><span class="line"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title function_">getWaitingThreads</span><span class="params">(Condition condition)</span></span><br><span class="line"><span class="comment">// 返回等待与此锁相关的给定条件的线程估计数。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getWaitQueueLength</span><span class="params">(Condition condition)</span></span><br><span class="line"><span class="comment">// 查询给定线程是否正在等待获取此锁。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">hasQueuedThread</span><span class="params">(Thread thread)</span></span><br><span class="line"><span class="comment">// 查询是否有些线程正在等待获取此锁。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">hasQueuedThreads</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 查询是否有些线程正在等待与此锁有关的给定条件。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">hasWaiters</span><span class="params">(Condition condition)</span></span><br><span class="line"><span class="comment">// 如果是“公平锁”返回true，否则返回false。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isFair</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 查询当前线程是否保持此锁。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isHeldByCurrentThread</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 查询此锁是否由任意线程保持。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isLocked</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 获取锁。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 如果当前线程未被中断，则获取锁。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 返回用来与此 Lock 实例一起使用的 Condition 实例。</span></span><br><span class="line">Condition <span class="title function_">newCondition</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 仅在调用时锁未被另一个线程保持的情况下，才获取该锁。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 如果锁在给定等待时间内没有被另一个线程保持，且当前线程未被中断，则获取该锁。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line"><span class="comment">// 试图释放此锁。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock示例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LockTest1.java</span></span><br><span class="line"><span class="comment">// 仓库</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Depot</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;        <span class="comment">// 仓库的实际数量</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock;        <span class="comment">// 独占锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Depot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            size += val;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s produce(%d) --&gt; size=%d\n&quot;</span>, </span><br><span class="line">                    Thread.currentThread().getName(), val, size);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            size -= val;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s consume(%d) &lt;-- size=%d\n&quot;</span>, </span><br><span class="line">                    Thread.currentThread().getName(), val, size);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Depot depot;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Depot depot)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.depot = depot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费产品：新建一个线程向仓库中生产产品。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                depot.produce(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Depot depot;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(Depot depot)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.depot = depot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费产品：新建一个线程从仓库中消费产品。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                depot.consume(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTest1</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Depot</span> <span class="variable">mDepot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Depot</span>();</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">mPro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(mDepot);</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">mCus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(mDepot);</span><br><span class="line"></span><br><span class="line">        mPro.produce(<span class="number">60</span>);</span><br><span class="line">        mPro.produce(<span class="number">120</span>);</span><br><span class="line">        mCus.consume(<span class="number">90</span>);</span><br><span class="line">        mCus.consume(<span class="number">150</span>);</span><br><span class="line">        mPro.produce(<span class="number">110</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread-<span class="number">0</span> produce(<span class="number">60</span>) --&gt; size=<span class="number">60</span></span><br><span class="line">Thread-<span class="number">1</span> produce(<span class="number">120</span>) --&gt; size=<span class="number">180</span></span><br><span class="line">Thread-<span class="number">3</span> consume(<span class="number">150</span>) &lt;-- size=<span class="number">30</span></span><br><span class="line">Thread-<span class="number">2</span> consume(<span class="number">90</span>) &lt;-- size=-<span class="number">60</span></span><br><span class="line">Thread-<span class="number">4</span> produce(<span class="number">110</span>) --&gt; size=<span class="number">50</span></span><br><span class="line"></span><br><span class="line">结果分析：</span><br><span class="line">(<span class="number">01</span>) Depot 是个仓库。通过produce()能往仓库中生产货物，通过consume()能消费仓库中的货物。通过独占锁lock实现对仓库的互斥访问：在操作(生产/消费)仓库中货品前，会先通过lock()锁住仓库，操作完之后再通过unlock()解锁。</span><br><span class="line">(<span class="number">02</span>) Producer是生产者类。调用Producer中的produce()函数可以新建一个线程往仓库中生产产品。</span><br><span class="line">(<span class="number">03</span>) Customer是消费者类。调用Customer中的consume()函数可以新建一个线程消费仓库中的产品。</span><br><span class="line">(<span class="number">04</span>) 在主线程main中，我们会新建<span class="number">1</span>个生产者mPro，同时新建<span class="number">1</span>个消费者mCus。它们分别向仓库中生产/消费产品。</span><br><span class="line">根据main中的生产/消费数量，仓库最终剩余的产品应该是<span class="number">50</span>。运行结果是符合我们预期的！</span><br><span class="line"></span><br><span class="line">这个模型存在两个问题：</span><br><span class="line">(<span class="number">01</span>) 现实中，仓库的容量不可能为负数。但是，此模型中的仓库容量可以为负数，这与现实相矛盾！</span><br><span class="line">(<span class="number">02</span>) 现实中，仓库的容量是有限制的。但是，此模型中的容量确实没有限制的！</span><br><span class="line">这两个问题，我们稍微会讲到如何解决。现在，先看个简单的示例<span class="number">2</span>；通过对比“示例<span class="number">1</span>”和“示例<span class="number">2</span>”,我们能更清晰的认识lock(),unlock()的用途。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在“示例2”中，我们通过Condition去解决“示例1”中的两个问题：</span></span><br><span class="line"><span class="comment">// “仓库的容量不可能为负数”</span></span><br><span class="line"><span class="comment">// “仓库的容量是有限制的”。</span></span><br><span class="line"><span class="comment">// 解决该问题是通过Condition。Condition是需要和Lock联合使用的：通过Condition中的await()方法，能让线程阻塞[类似于wait()]；通过Condition的signal()方法，能让唤醒线程[类似于notify()]。</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LockTest3.java</span></span><br><span class="line"><span class="comment">// 仓库</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Depot</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;    <span class="comment">// 仓库的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;        <span class="comment">// 仓库的实际数量</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock;        <span class="comment">// 独占锁</span></span><br><span class="line">    <span class="keyword">private</span> Condition fullCondtion;            <span class="comment">// 生产条件</span></span><br><span class="line">    <span class="keyword">private</span> Condition emptyCondtion;        <span class="comment">// 消费条件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Depot</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="built_in">this</span>.fullCondtion = lock.newCondition();</span><br><span class="line">        <span class="built_in">this</span>.emptyCondtion = lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// left 表示“想要生产的数量”(有可能生产量太多，需多此生产)</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> val;</span><br><span class="line">            <span class="keyword">while</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 库存已满时，等待“消费者”消费产品。</span></span><br><span class="line">                <span class="keyword">while</span> (size &gt;= capacity)</span><br><span class="line">                    fullCondtion.await();</span><br><span class="line">                <span class="comment">// 获取“实际生产的数量”(即库存中新增的数量)</span></span><br><span class="line">                <span class="comment">// 如果“库存”+“想要生产的数量”&gt;“总的容量”，则“实际增量”=“总的容量”-“当前容量”。(此时填满仓库)</span></span><br><span class="line">                <span class="comment">// 否则“实际增量”=“想要生产的数量”</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> (size+left)&gt;capacity ? (capacity-size) : left;</span><br><span class="line">                size += inc;</span><br><span class="line">                left -= inc;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s produce(=) --&gt; left==, inc==, size==\n&quot;</span>, </span><br><span class="line">                        Thread.currentThread().getName(), val, left, inc, size);</span><br><span class="line">                <span class="comment">// 通知“消费者”可以消费了。</span></span><br><span class="line">                emptyCondtion.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// left 表示“客户要消费数量”(有可能消费量太大，库存不够，需多此消费)</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> val;</span><br><span class="line">            <span class="keyword">while</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 库存为0时，等待“生产者”生产产品。</span></span><br><span class="line">                <span class="keyword">while</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">                    emptyCondtion.await();</span><br><span class="line">                <span class="comment">// 获取“实际消费的数量”(即库存中实际减少的数量)</span></span><br><span class="line">                <span class="comment">// 如果“库存”&lt;“客户要消费的数量”，则“实际消费量”=“库存”；</span></span><br><span class="line">                <span class="comment">// 否则，“实际消费量”=“客户要消费的数量”。</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">dec</span> <span class="operator">=</span> (size&lt;left) ? size : left;</span><br><span class="line">                size -= dec;</span><br><span class="line">                left -= dec;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s consume(=) &lt;-- left==, dec==, size==\n&quot;</span>, </span><br><span class="line">                        Thread.currentThread().getName(), val, left, dec, size);</span><br><span class="line">                fullCondtion.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;capacity:&quot;</span>+capacity+<span class="string">&quot;, actual size:&quot;</span>+size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Depot depot;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Depot depot)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.depot = depot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费产品：新建一个线程向仓库中生产产品。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                depot.produce(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Depot depot;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(Depot depot)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.depot = depot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费产品：新建一个线程从仓库中消费产品。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                depot.consume(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTest3</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Depot</span> <span class="variable">mDepot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Depot</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">mPro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(mDepot);</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">mCus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(mDepot);</span><br><span class="line"></span><br><span class="line">        mPro.produce(<span class="number">60</span>);</span><br><span class="line">        mPro.produce(<span class="number">120</span>);</span><br><span class="line">        mCus.consume(<span class="number">90</span>);</span><br><span class="line">        mCus.consume(<span class="number">150</span>);</span><br><span class="line">        mPro.produce(<span class="number">110</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread-<span class="number">0</span> produce( <span class="number">60</span>) --&gt; left=  <span class="number">0</span>, inc= <span class="number">60</span>, size= <span class="number">60</span></span><br><span class="line">Thread-<span class="number">1</span> produce(<span class="number">120</span>) --&gt; left= <span class="number">80</span>, inc= <span class="number">40</span>, size=<span class="number">100</span></span><br><span class="line">Thread-<span class="number">2</span> consume( <span class="number">90</span>) &lt;-- left=  <span class="number">0</span>, dec= <span class="number">90</span>, size= <span class="number">10</span></span><br><span class="line">Thread-<span class="number">3</span> consume(<span class="number">150</span>) &lt;-- left=<span class="number">140</span>, dec= <span class="number">10</span>, size=  <span class="number">0</span></span><br><span class="line">Thread-<span class="number">4</span> produce(<span class="number">110</span>) --&gt; left= <span class="number">10</span>, inc=<span class="number">100</span>, size=<span class="number">100</span></span><br><span class="line">Thread-<span class="number">3</span> consume(<span class="number">150</span>) &lt;-- left= <span class="number">40</span>, dec=<span class="number">100</span>, size=  <span class="number">0</span></span><br><span class="line">Thread-<span class="number">4</span> produce(<span class="number">110</span>) --&gt; left=  <span class="number">0</span>, inc= <span class="number">10</span>, size= <span class="number">10</span></span><br><span class="line">Thread-<span class="number">3</span> consume(<span class="number">150</span>) &lt;-- left= <span class="number">30</span>, dec= <span class="number">10</span>, size=  <span class="number">0</span></span><br><span class="line">Thread-<span class="number">1</span> produce(<span class="number">120</span>) --&gt; left=  <span class="number">0</span>, inc= <span class="number">80</span>, size= <span class="number">80</span></span><br><span class="line">Thread-<span class="number">3</span> consume(<span class="number">150</span>) &lt;-- left=  <span class="number">0</span>, dec= <span class="number">30</span>, size= <span class="number">50</span></span><br></pre></td></tr></table></figure>
<h1 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h1><p><strong>基本概念</strong>:</p>
<ul>
<li><p><strong>AQS</strong>  — 指AbstractQueuedSynchronizer类。<br>AQS是java中管理“锁”的抽象类，锁的许多公共方法都是在这个类中实现。AQS是独占锁(例如，ReentrantLock)和共享锁(例如，Semaphore)的公共父类。</p>
</li>
<li><p>AQS<strong>锁的类别</strong> — 分为“独占锁”和“共享锁”两种。<br>(01) 独占锁 — 锁在一个时间点只能被一个线程锁占有。根据锁的获取机制，它又划分为“公平锁”和“非公平锁”。公平锁，是按照通过CLH等待线程按照先来先得的规则，公平的获取锁；而非公平锁，则当线程要获取锁时，它会无视CLH等待队列而直接获取锁。独占锁的典型实例子是ReentrantLock，此外，ReentrantReadWriteLock.WriteLock也是独占锁。<br>(02) 共享锁 — 能被多个线程同时拥有，能被共享的锁。JUC包中的ReentrantReadWriteLock.ReadLock，CyclicBarrier， CountDownLatch和Semaphore都是共享锁。这些锁的用途和原理，在以后的章节再详细介绍。</p>
</li>
<li><p><strong>CLH队列</strong> — Craig, Landin, and Hagersten lock queue<br>CLH队列是AQS中“等待锁”的线程队列。在多线程中，为了保护竞争资源不被多个线程同时操作而起来错误，我们常常需要通过锁来保护这些资源。在独占锁中，竞争资源在一个时间点只能被一个线程锁访问；而其它线程则需要等待。CLH就是管理这些“等待锁”的线程的队列。<br>CLH是一个非阻塞的 FIFO 队列。也就是说往里面插入或移除一个节点的时候，在并发条件下不会阻塞，而是通过自旋锁和 CAS 保证节点插入和移除的原子性。</p>
</li>
<li><p><strong>CAS函数</strong> — Compare And Swap<br>CAS函数，是比较并交换函数，它是原子操作函数；即，通过CAS操作的数据都是以原子方式进行的。例如，compareAndSetHead(), compareAndSetTail(), compareAndSetNext()等函数。它们共同的特点是，这些函数所执行的动作是以原子的方式进行的。</p>
</li>
</ul>
<h2 id="获取公平锁"><a href="#获取公平锁" class="headerlink" title="获取公平锁"></a>获取公平锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> lock()</span><br><span class="line">lock()在ReentrantLock.java的FairSync类中实现</span><br><span class="line">说明：“当前线程”实际上是通过acquire(<span class="number">1</span>)获取锁的。</span><br><span class="line">	这里说明一下“<span class="number">1</span>”的含义，它是设置“锁的状态”的参数。对于“独占锁”而言，锁处于可获取状态时，它的状态值是<span class="number">0</span>；锁被线程初次获取到了，它的状态值就变成了<span class="number">1</span>。</span><br><span class="line">	由于ReentrantLock(公平锁/非公平锁)是可重入锁，所以“独占锁”可以被单个线程多此获取，每获取<span class="number">1</span>次就将锁的状态+<span class="number">1</span>。也就是说，初次获取锁时，通过acquire(<span class="number">1</span>)将锁的状态值设为<span class="number">1</span>；再次获取锁时，将锁的状态值设为<span class="number">2</span>；依次类推...这就是为什么获取锁时，传入的参数是<span class="number">1</span>的原因了。</span><br><span class="line">	可重入就是指锁可以被单个线程多次获取。</span><br><span class="line">        </span><br><span class="line"><span class="number">2.</span> acquire()</span><br><span class="line">acquire()在AQS中实现的</span><br><span class="line">(<span class="number">01</span>) “当前线程”首先通过tryAcquire()尝试获取锁。获取成功的话，直接返回；尝试失败的话，进入到等待队列排序等待(前面还有可能有需要线程在等待该锁)。</span><br><span class="line">(<span class="number">02</span>) “当前线程”尝试失败的情况下，先通过addWaiter(Node.EXCLUSIVE)来将“当前线程”加入到<span class="string">&quot;CLH队列(非阻塞的FIFO队列)&quot;</span>末尾。CLH队列就是线程等待队列。</span><br><span class="line">(<span class="number">03</span>) 再执行完addWaiter(Node.EXCLUSIVE)之后，会调用acquireQueued()来获取锁。由于此时ReentrantLock是公平锁，它会根据公平性原则来获取锁。</span><br><span class="line">(<span class="number">04</span>) “当前线程”在执行acquireQueued()时，会进入到CLH队列中休眠等待，直到获取锁了才返回！如果“当前线程”在休眠等待过程中被中断过，acquireQueued会返回<span class="literal">true</span>，此时<span class="string">&quot;当前线程&quot;</span>会调用selfInterrupt()来自己给自己产生一个中断。</span><br></pre></td></tr></table></figure>
<h2 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire()"></a>tryAcquire()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> tryAcquire()</span><br><span class="line">说明：根据代码，我们可以分析出，tryAcquire()的作用就是尝试去获取锁。注意，这里只是尝试！</span><br><span class="line">	尝试成功的话，返回<span class="literal">true</span>；尝试失败的话，返回<span class="literal">false</span>，后续再通过其它办法来获取该锁。后面我们会说明，在尝试失败的情况下，是如何一步步获取锁的。</span><br><span class="line">	</span><br><span class="line"><span class="number">2.</span> hasQueuedPredecessors()</span><br><span class="line">说明：通过代码，能分析出，hasQueuedPredecessors() 是通过判断<span class="string">&quot;当前线程&quot;</span>是不是在CLH队列的队首，来返回AQS中是不是有比“当前线程”等待更久的线程。下面对head、tail和Node进行说明。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> Node的源码</span><br><span class="line">说明：Node是CLH队列的节点，代表“等待锁的线程队列”。</span><br><span class="line">(<span class="number">01</span>) 每个Node都会一个线程对应。</span><br><span class="line">(<span class="number">02</span>) 每个Node会通过prev和next分别指向上一个节点和下一个节点，这分别代表上一个等待线程和下一个等待线程。</span><br><span class="line">(<span class="number">03</span>) Node通过waitStatus保存线程的等待状态。</span><br><span class="line">(<span class="number">04</span>) Node通过nextWaiter来区分线程是“独占锁”线程还是“共享锁”线程。如果是“独占锁”线程，则nextWaiter的值为EXCLUSIVE；如果是“共享锁”线程，则nextWaiter的值是SHARED。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> compareAndSetState()</span><br><span class="line">说明： compareAndSwapInt() 是sun.misc.Unsafe类中的一个本地方法。对此，我们需要了解的是 compareAndSetState(expect, update) 是以原子的方式操作当前线程；若当前线程的状态为expect，则设置它的状态为update。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> setExclusiveOwnerThread()</span><br><span class="line">说明：setExclusiveOwnerThread()的作用就是，设置线程t为当前拥有“独占锁”的线程</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> getState(), setState()</span><br><span class="line">说明：state表示锁的状态，对于“独占锁”而已，state=<span class="number">0</span>表示锁是可获取状态(即，锁没有被任何线程锁持有)。由于java中的独占锁是可重入的，state的值可以&gt;<span class="number">1</span>。</span><br></pre></td></tr></table></figure>
<h2 id="addWaiter-Node-EXCLUSIVE"><a href="#addWaiter-Node-EXCLUSIVE" class="headerlink" title="addWaiter(Node.EXCLUSIVE)"></a>addWaiter(Node.EXCLUSIVE)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">addWaiter(Node.EXCLUSIVE)的作用是，创建“当前线程”的Node节点，且Node中记录“当前线程”对应的锁是“独占锁”类型，并且将该节点添加到CLH队列的末尾。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>addWaiter()</span><br><span class="line">说明：对于“公平锁”而言，addWaiter(Node.EXCLUSIVE)会首先创建一个Node节点，节点的类型是“独占锁”(Node.EXCLUSIVE)类型。然后，再将该节点添加到CLH队列的末尾。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> compareAndSetTail()</span><br><span class="line">说明：compareAndSetTail也属于CAS函数，也是通过“本地方法”实现的。compareAndSetTail(expect, update)会以原子的方式进行操作，它的作用是判断CLH队列的队尾是不是为expect，是的话，就将队尾设为update。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> enq()</span><br><span class="line">说明： enq()的作用很简单。如果CLH队列为空，则新建一个CLH表头；然后将node添加到CLH末尾。否则，直接将node添加到CLH末尾。</span><br><span class="line"></span><br><span class="line">小结：addWaiter()的作用，就是将当前线程添加到CLH队列中。这就意味着将当前线程添加到等待获取“锁”的等待线程队列中了。</span><br></pre></td></tr></table></figure>
<h2 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued()"></a>acquireQueued()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">acquireQueued()的作用就是逐步的去执行CLH队列的线程，如果当前线程获取到了锁，则返回；否则，当前线程进行休眠，直到唤醒并重新获取锁了才返回。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> acquireQueued()</span><br><span class="line">说明：acquireQueued()的目的是从队列中获取锁。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> shouldParkAfterFailedAcquire()</span><br><span class="line">说明：</span><br><span class="line">(<span class="number">01</span>) 关于waitStatus请参考下表(中扩号内为waitStatus的值)，更多关于waitStatus的内容，可以参考前面的Node类的介绍。</span><br><span class="line">    CANCELLED[<span class="number">1</span>]  -- 当前线程已被取消</span><br><span class="line">    SIGNAL[-<span class="number">1</span>]    -- “当前线程的后继线程需要被unpark(唤醒)”。一般发生情况是：当前线程的后继线程处于阻塞状态，而当前线程被release或cancel掉，因此需要唤醒当前线程的后继线程。</span><br><span class="line">    CONDITION[-<span class="number">2</span>] -- 当前线程(处在Condition休眠状态)在等待Condition唤醒</span><br><span class="line">    PROPAGATE[-<span class="number">3</span>] -- (共享锁)其它线程获取到“共享锁”</span><br><span class="line">    [<span class="number">0</span>]           -- 当前线程不属于上面的任何一种状态。</span><br><span class="line">(<span class="number">02</span>) shouldParkAfterFailedAcquire()通过以下规则，判断“当前线程”是否需要被阻塞。</span><br><span class="line">    规则<span class="number">1</span>：如果前继节点状态为SIGNAL，表明当前节点需要被unpark(唤醒)，此时则返回<span class="literal">true</span>。</span><br><span class="line">    规则<span class="number">2</span>：如果前继节点状态为CANCELLED(ws&gt;<span class="number">0</span>)，说明前继节点已经被取消，则通过先前回溯找到一个有效(非CANCELLED状态)的节点，并返回<span class="literal">false</span>。</span><br><span class="line">    规则<span class="number">3</span>：如果前继节点状态为非SIGNAL、非CANCELLED，则设置前继的状态为SIGNAL，并返回<span class="literal">false</span>。</span><br><span class="line">如果“规则<span class="number">1</span>”发生，即“前继节点是SIGNAL”状态，则意味着“当前线程”需要被阻塞。接下来会调用parkAndCheckInterrupt()阻塞当前线程，直到当前先被唤醒才从parkAndCheckInterrupt()中返回。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> parkAndCheckInterrupt())</span><br><span class="line">说明：parkAndCheckInterrupt()的作用是阻塞当前线程，并且返回“线程被唤醒之后”的中断状态。</span><br><span class="line">它会先通过LockSupport.park()阻塞“当前线程”，然后通过Thread.interrupted()返回线程的中断状态。</span><br><span class="line"></span><br><span class="line">这里介绍一下线程被阻塞之后如何唤醒。一般有<span class="number">2</span>种情况：</span><br><span class="line">第<span class="number">1</span>种情况：unpark()唤醒。“前继节点对应的线程”使用完锁之后，通过unpark()方式唤醒当前线程。</span><br><span class="line">第<span class="number">2</span>种情况：中断唤醒。其它线程通过interrupt()中断当前线程。</span><br><span class="line"></span><br><span class="line">补充：LockSupport()中的park(),unpark()的作用 和 Object中的wait(),notify()作用类似，是阻塞/唤醒。</span><br><span class="line">它们的用法不同，park(),unpark()是轻量级的，而wait(),notify()是必须先通过Synchronized获取同步锁。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 再次tryAcquire()</span><br><span class="line">说明：</span><br><span class="line">(<span class="number">01</span>) 通过node.predecessor()获取前继节点。predecessor()就是返回node的前继节点，若对此有疑惑可以查看下面关于Node类的介绍。</span><br><span class="line">(<span class="number">02</span>) p == head &amp;&amp; tryAcquire(arg)</span><br><span class="line">首先，判断“前继节点”是不是CHL表头。如果是的话，则通过tryAcquire()尝试获取锁。</span><br><span class="line">其实，这样做的目的是为了“让当前线程获取锁”，但是为什么需要先判断p==head呢？理解这个对理解“公平锁”的机制很重要，因为这么做的原因就是为了保证公平性！</span><br><span class="line">	(a) 前面，我们在shouldParkAfterFailedAcquire()我们判断“当前线程”是否需要阻塞；</span><br><span class="line">	(b) 接着，“当前线程”阻塞的话，会调用parkAndCheckInterrupt()来阻塞线程。当线程被解除阻塞的时候，我们会返回线程的中断状态。而线程被解决阻塞，可能是由于“线程被中断”，也可能是由于“其它线程调用了该线程的unpark()函数”。</span><br><span class="line">	(c) 再回到p==head这里。如果当前线程是因为其它线程调用了unpark()函数而被唤醒，那么唤醒它的线程，应该是它的前继节点所对应的线程(关于这一点，后面在“释放锁”的过程中会看到)。 OK，是前继节点调用unpark()唤醒了当前线程！</span><br><span class="line">此时，再来理解p==head就很简单了：当前继节点是CLH队列的头节点，并且它释放锁之后；就轮到当前节点获取锁了。然后，当前节点通过tryAcquire()获取锁；获取成功的话，通过setHead(node)设置当前节点为头节点，并返回。</span><br><span class="line">	总之，如果“前继节点调用unpark()唤醒了当前线程”并且“前继节点是CLH表头”，此时就是满足p==head，也就是符合公平性原则的。否则，如果当前线程是因为“线程被中断”而唤醒，那么显然就不是公平了。这就是为什么说p==head就是保证公平性！</span><br><span class="line"></span><br><span class="line">小结：acquireQueued()的作用就是“当前线程”会根据公平性原则进行阻塞等待，直到获取锁为止；并且返回当前线程在等待过程中有没有并中断过。</span><br></pre></td></tr></table></figure>
<h2 id="selfInterrupt"><a href="#selfInterrupt" class="headerlink" title="selfInterrupt()"></a>selfInterrupt()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selfInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：selfInterrupt()的代码很简单，就是“当前线程”自己产生一个中断。但是，为什么需要这么做呢？</span><br><span class="line">这必须结合acquireQueued()进行分析。如果在acquireQueued()中，当前线程被中断过，则执行selfInterrupt()；否则不会执行。</span><br><span class="line"></span><br><span class="line">在acquireQueued()中，即使是线程在阻塞状态被中断唤醒而获取到cpu执行权利；但是，如果该线程的前面还有其它等待锁的线程，根据公平性原则，该线程依然无法获取到锁。它会再次阻塞！ 该线程再次阻塞，直到该线程被它的前面等待锁的线程锁唤醒；线程才会获取锁，然后“真正执行起来”！</span><br><span class="line">也就是说，在该线程“成功获取锁并真正执行起来”之前，它的中断会被忽略并且中断标记会被清除！ 因为在parkAndCheckInterrupt()中，我们线程的中断状态时调用了Thread.interrupted()。该函数不同于Thread的isInterrupted()函数，isInterrupted()仅仅返回中断状态，而interrupted()在返回当前中断状态之后，还会清除中断状态。 正因为之前的中断状态被清除了，所以这里需要调用selfInterrupt()重新产生一个中断！</span><br><span class="line">小结：selfInterrupt()的作用就是当前线程自己产生一个中断。</span><br><span class="line"></span><br><span class="line">总结:</span><br><span class="line">再回过头看看acquire()函数，它最终的目的是获取锁！</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line">(<span class="number">01</span>) 先是通过tryAcquire()尝试获取锁。获取成功的话，直接返回；尝试失败的话，再通过acquireQueued()获取锁。</span><br><span class="line">(<span class="number">02</span>) 尝试失败的情况下，会先通过addWaiter()来将“当前线程”加入到<span class="string">&quot;CLH队列&quot;</span>末尾；然后调用acquireQueued()，在CLH队列中排序等待获取锁，在此过程中，线程处于休眠状态。直到获取锁了才返回。 如果在休眠等待过程中被中断过，则调用selfInterrupt()来自己产生一个中断。</span><br></pre></td></tr></table></figure>
<h2 id="释放公平锁"><a href="#释放公平锁" class="headerlink" title="释放公平锁"></a>释放公平锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> unlock()</span><br><span class="line">说明：unlock()是解锁函数，它是通过AQS的release()函数来实现的。</span><br><span class="line">在这里，“<span class="number">1</span>”的含义和“获取锁的函数acquire(<span class="number">1</span>)的含义”一样，它是设置“释放锁的状态”的参数。由于“公平锁”是可重入的，所以对于同一个线程，每释放锁一次，锁的状态-<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> release()</span><br><span class="line">说明：release()会先调用tryRelease()来尝试释放当前线程锁持有的锁。成功的话，则唤醒后继等待线程，并返回<span class="literal">true</span>。否则，直接返回<span class="literal">false</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> tryRelease()</span><br><span class="line">说明：tryRelease()的作用是尝试释放锁。</span><br><span class="line">(<span class="number">01</span>) 如果“当前线程”不是“锁的持有者”，则抛出异常。</span><br><span class="line">(<span class="number">02</span>) 如果“当前线程”在本次释放锁操作之后，对锁的拥有状态是<span class="number">0</span>(即，当前线程彻底释放该“锁”)，则设置“锁”的持有者为<span class="literal">null</span>，即锁是可获取状态。同时，更新当前线程的锁的状态为<span class="number">0</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> unparkSuccessor()</span><br><span class="line">在release()中“当前线程”释放锁成功的话，会唤醒当前线程的后继线程。</span><br><span class="line">根据CLH队列的FIFO规则，“当前线程”(即已经获取锁的线程)肯定是head；如果CLH队列非空的话，则唤醒锁的下一个等待线程。</span><br><span class="line">说明：unparkSuccessor()的作用是“唤醒当前线程的后继线程”。后继线程被唤醒之后，就可以获取该锁并恢复运行了。</span><br><span class="line">关</span><br><span class="line"></span><br><span class="line">总结: “释放锁”的过程相对“获取锁”的过程比较简单。释放锁时，主要进行的操作，是更新当前线程对应的锁的状态。如果当前线程对锁已经彻底释放，则设置“锁”的持有线程为<span class="literal">null</span>，设置当前线程的状态为空，然后唤醒后继线程。</span><br></pre></td></tr></table></figure>
<h1 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h1><h2 id="获取非公平锁"><a href="#获取非公平锁" class="headerlink" title="获取非公平锁"></a>获取非公平锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">非公平锁和公平锁在获取锁的方法上，流程是一样的；它们的区别主要表现在“尝试获取锁的机制不同”。简单点说，“公平锁”在每次尝试获取锁时，都是采用公平策略(根据等待队列依次排序等待)；而“非公平锁”在每次尝试获取锁时，都是采用的非公平策略(无视等待队列，直接尝试获取锁，如果锁是空闲的，即可获取状态，则获取锁)。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> lock()</span><br><span class="line">说明：lock()会先通过compareAndSet(<span class="number">0</span>, <span class="number">1</span>)来判断“锁”是不是空闲状态。是的话，“当前线程”直接获取“锁”；否则的话，调用acquire(<span class="number">1</span>)获取锁。</span><br><span class="line">(<span class="number">01</span>) compareAndSetState()是CAS函数，它的作用是比较并设置当前锁的状态。若锁的状态值为<span class="number">0</span>，则设置锁的状态值为<span class="number">1</span>。</span><br><span class="line">(<span class="number">02</span>) setExclusiveOwnerThread(Thread.currentThread())的作用是，设置“当前线程”为“锁”的持有者。</span><br><span class="line"></span><br><span class="line">“公平锁”和“非公平锁”关于lock()的对比</span><br><span class="line">公平锁   -- 公平锁的lock()函数，会直接调用acquire(<span class="number">1</span>)。</span><br><span class="line">非公平锁 -- 非公平锁会先判断当前锁的状态是不是空闲，是的话，就不排队，而是直接获取锁。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> acquire()</span><br><span class="line">(<span class="number">01</span>) “当前线程”首先通过tryAcquire()尝试获取锁。获取成功的话，直接返回；尝试失败的话，进入到等待队列依次排序，然后获取锁。</span><br><span class="line">(<span class="number">02</span>) “当前线程”尝试失败的情况下，会先通过addWaiter(Node.EXCLUSIVE)来将“当前线程”加入到<span class="string">&quot;CLH队列(非阻塞的FIFO队列)&quot;</span>末尾。</span><br><span class="line">(<span class="number">03</span>) 然后，调用acquireQueued()获取锁。在acquireQueued()中，当前线程会等待它在“CLH队列”中前面的所有线程执行并释放锁之后，才能获取锁并返回。如果“当前线程”在休眠等待过程中被中断过，则调用selfInterrupt()来自己产生一个中断。</span><br><span class="line"></span><br><span class="line">“公平锁”和“非公平锁”关于acquire()的对比</span><br><span class="line">公平锁和非公平锁，只有tryAcquire()函数的实现不同；即它们尝试获取锁的机制不同。这就是我们所说的“它们获取锁策略的不同所在之处”！</span><br><span class="line">在“Java多线程系列--“JUC锁”<span class="number">03</span>之 公平锁(一)”中，已经详细介绍了acquire()涉及到的各个函数。这里仅对它们有差异的函数tryAcquire()进行说明。</span><br><span class="line">    </span><br><span class="line">说明：</span><br><span class="line">根据代码，我们可以分析出，tryAcquire()的作用就是尝试去获取锁。</span><br><span class="line">(<span class="number">01</span>) 如果“锁”没有被任何线程拥有，则通过CAS函数设置“锁”的状态为acquires，同时，设置“当前线程”为锁的持有者，然后返回<span class="literal">true</span>。</span><br><span class="line">(<span class="number">02</span>) 如果“锁”的持有者已经是当前线程，则将更新锁的状态即可。</span><br><span class="line">(<span class="number">03</span>) 如果不术语上面的两种情况，则认为尝试失败。</span><br><span class="line"></span><br><span class="line">“公平锁”和“非公平锁”关于tryAcquire()的对比</span><br><span class="line">公平锁和非公平锁，它们尝试获取锁的方式不同。</span><br><span class="line">公平锁在尝试获取锁时，即使“锁”没有被任何线程锁持有，它也会判断自己是不是CLH等待队列的表头；是的话，才获取锁。</span><br><span class="line">而非公平锁在尝试获取锁时，如果“锁”没有被任何线程持有，则不管它在CLH队列的何处，它都直接获取锁。 </span><br></pre></td></tr></table></figure>
<h2 id="释放非公平锁"><a href="#释放非公平锁" class="headerlink" title="释放非公平锁"></a>释放非公平锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">非公平锁和公平锁在释放锁的方法和策略上是一样的。</span><br></pre></td></tr></table></figure>
<h1 id="Condition条件"><a href="#Condition条件" class="headerlink" title="Condition条件"></a>Condition条件</h1><p>Condition的作用是对锁进行更精确的控制。Condition中的await()方法相当于Object的wait()方法，Condition中的signal()方法相当于Object的notify()方法，Condition中的signalAll()相当于Object的notifyAll()方法。不同的是，Object中的wait(),notify(),notifyAll()方法是和”同步锁”(synchronized关键字)捆绑使用的；而Condition是需要与”互斥锁”/“共享锁”捆绑使用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Condition函数列表</span></span><br><span class="line"><span class="comment">// 造成当前线程在接到信号或被中断之前一直处于等待状态。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span></span><br><span class="line"><span class="comment">// 造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span></span><br><span class="line"><span class="comment">// 造成当前线程在接到信号之前一直处于等待状态。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span></span><br><span class="line"><span class="comment">// 唤醒一个等待线程。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 唤醒所有等待线程。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<h2 id="Condition示例"><a href="#Condition示例" class="headerlink" title="Condition示例"></a>Condition示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1是通过Object的wait(), notify()来演示线程的休眠/唤醒功能。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadA</span> <span class="variable">ta</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>(<span class="string">&quot;ta&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span>(ta) &#123; <span class="comment">// 通过synchronized(ta)获取“对象ta的同步锁”</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">       System.out.println(Thread.currentThread().getName()+<span class="string">&quot; start ta&quot;</span>);</span><br><span class="line">                ta.start();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; block&quot;</span>);</span><br><span class="line">                ta.wait();    <span class="comment">// 等待</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; continue&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ThreadA</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123; <span class="comment">// 通过synchronized(this)获取“当前对象的同步锁”</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; wakup others&quot;</span>);</span><br><span class="line">                notify();    <span class="comment">// 唤醒“当前对象上的等待线程”</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例2是通过Condition的await(), signal()来演示线程的休眠/唤醒功能。</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionTest1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadA</span> <span class="variable">ta</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>(<span class="string">&quot;ta&quot;</span>);</span><br><span class="line">        lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; start ta&quot;</span>);</span><br><span class="line">            ta.start();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; block&quot;</span>);</span><br><span class="line">            condition.await();    <span class="comment">// 等待</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; continue&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();    <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ThreadA</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            lock.lock();    <span class="comment">// 获取锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; wakup others&quot;</span>);</span><br><span class="line">                condition.signal();    <span class="comment">// 唤醒“condition所在锁上的其它线程”</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();    <span class="comment">// 释放锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">main start ta</span><br><span class="line">main block</span><br><span class="line">ta wakup others</span><br><span class="line">main <span class="keyword">continue</span></span><br><span class="line">通过“示例<span class="number">1</span>”和“示例<span class="number">2</span>”，我们知道Condition和Object的方法有一下对应关系：</span><br><span class="line">              Object      Condition  </span><br><span class="line">休眠          wait        await</span><br><span class="line">唤醒个线程     notify      signal</span><br><span class="line">唤醒所有线程   notifyAll   signalAll</span><br><span class="line"></span><br><span class="line">Condition除了支持上面的功能之外，它更强大的地方在于：能够更加精细的控制多线程的休眠与唤醒。对于同一个锁，我们可以创建多个Condition，在不同的情况下使用不同的Condition。</span><br><span class="line">例如，假如多线程读/写同一个缓冲区：当向缓冲区中写入数据之后，唤醒<span class="string">&quot;读线程&quot;</span>；当从缓冲区读出数据之后，唤醒<span class="string">&quot;写线程&quot;</span>；并且当缓冲区满的时候，<span class="string">&quot;写线程&quot;</span>需要等待；当缓冲区为空时，<span class="string">&quot;读线程&quot;</span>需要等待。</span><br><span class="line">如果采用Object类中的wait(), notify(), notifyAll()实现该缓冲区，当向缓冲区写入数据之后需要唤醒<span class="string">&quot;读线程&quot;</span>时，不可能通过notify()或notifyAll()明确的指定唤醒<span class="string">&quot;读线程&quot;</span>，而只能通过notifyAll唤醒所有线程(但是notifyAll无法区分唤醒的线程是读线程，还是写线程)。  但是，通过Condition，就能明确的指定唤醒读线程。</span><br><span class="line">看看下面的示例<span class="number">3</span>，可能对这个概念有更深刻的理解。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例3是通过Condition的高级功能。</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BoundedBuffer</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span>  <span class="operator">=</span> lock.newCondition(); </span><br><span class="line">    <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition(); </span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> putptr, takeptr, count;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();    <span class="comment">//获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果“缓冲已满”，则等待；直到“缓冲”不是满的，才将x添加到缓冲中。</span></span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            <span class="comment">// 将x添加到缓冲中</span></span><br><span class="line">            items[putptr] = x; </span><br><span class="line">            <span class="comment">// 将“put统计数putptr+1”；如果“缓冲已满”，则设putptr为0。</span></span><br><span class="line">            <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 将“缓冲”数量+1</span></span><br><span class="line">            ++count;</span><br><span class="line">            <span class="comment">// 唤醒take线程，因为take线程通过notEmpty.await()等待</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">            <span class="comment">// 打印写入的数据</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; put  &quot;</span>+ (Integer)x);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();    <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();    <span class="comment">//获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果“缓冲为空”，则等待；直到“缓冲”不为空，才将x从缓冲中取出。</span></span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) </span><br><span class="line">                notEmpty.await();</span><br><span class="line">            <span class="comment">// 将x从缓冲中取出</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> items[takeptr]; </span><br><span class="line">            <span class="comment">// 将“take统计数takeptr+1”；如果“缓冲为空”，则设takeptr为0。</span></span><br><span class="line">            <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 将“缓冲”数量-1</span></span><br><span class="line">            --count;</span><br><span class="line">            <span class="comment">// 唤醒put线程，因为put线程通过notFull.await()等待</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">            <span class="comment">// 打印取出的数据</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; take &quot;</span>+ (Integer)x);</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();    <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionTest2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">BoundedBuffer</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BoundedBuffer</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 启动10个“写线程”，向BoundedBuffer中不断的写数据(写入0-9)；</span></span><br><span class="line">        <span class="comment">// 启动10个“读线程”，从BoundedBuffer中不断的读数据。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PutThread</span>(<span class="string">&quot;p&quot;</span>+i, i).start();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">TakeThread</span>(<span class="string">&quot;t&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PutThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">PutThread</span><span class="params">(String name, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">            <span class="built_in">this</span>.num = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);    <span class="comment">// 线程休眠1ms</span></span><br><span class="line">                bb.put(num);        <span class="comment">// 向BoundedBuffer中写入数据</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TakeThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TakeThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);                    <span class="comment">// 线程休眠1ms</span></span><br><span class="line">                <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> (Integer)bb.take();    <span class="comment">// 从BoundedBuffer中取出数据</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">某一次结果:</span><br><span class="line">p1 put  <span class="number">1</span></span><br><span class="line">p4 put  <span class="number">4</span></span><br><span class="line">p5 put  <span class="number">5</span></span><br><span class="line">p0 put  <span class="number">0</span></span><br><span class="line">p2 put  <span class="number">2</span></span><br><span class="line">t0 take <span class="number">1</span></span><br><span class="line">p3 put  <span class="number">3</span></span><br><span class="line">t1 take <span class="number">4</span></span><br><span class="line">p6 put  <span class="number">6</span></span><br><span class="line">t2 take <span class="number">5</span></span><br><span class="line">p7 put  <span class="number">7</span></span><br><span class="line">t3 take <span class="number">0</span></span><br><span class="line">p8 put  <span class="number">8</span></span><br><span class="line">t4 take <span class="number">2</span></span><br><span class="line">p9 put  <span class="number">9</span></span><br><span class="line">t5 take <span class="number">3</span></span><br><span class="line">t6 take <span class="number">6</span></span><br><span class="line">t7 take <span class="number">7</span></span><br><span class="line">t8 take <span class="number">8</span></span><br><span class="line">t9 take <span class="number">9</span></span><br><span class="line">    </span><br><span class="line">结果说明：</span><br><span class="line">(<span class="number">01</span>) BoundedBuffer 是容量为<span class="number">5</span>的缓冲，缓冲中存储的是Object对象，支持多线程的读/写缓冲。多个线程操作“一个BoundedBuffer对象”时，它们通过互斥锁lock对缓冲区items进行互斥访问；而且同一个BoundedBuffer对象下的全部线程共用“notFull”和“notEmpty”这两个Condition。</span><br><span class="line">    notFull用于控制写缓冲，notEmpty用于控制读缓冲。当缓冲已满的时候，调用put的线程会执行notFull.await()进行等待；当缓冲区不是满的状态时，就将对象添加到缓冲区并将缓冲区的容量count+<span class="number">1</span>，最后，调用notEmpty.signal()缓冲notEmpty上的等待线程(调用notEmpty.await的线程)。 简言之，notFull控制“缓冲区的写入”，当往缓冲区写入数据之后会唤醒notEmpty上的等待线程。</span><br><span class="line">	同理，notEmpty控制“缓冲区的读取”，当读取了缓冲区数据之后会唤醒notFull上的等待线程。</span><br><span class="line">(<span class="number">02</span>) 在ConditionTest2的main函数中，启动<span class="number">10</span>个“写线程”，向BoundedBuffer中不断的写数据(写入<span class="number">0</span>-<span class="number">9</span>)；同时，也启动<span class="number">10</span>个“读线程”，从BoundedBuffer中不断的读数据。</span><br><span class="line">(<span class="number">03</span>) 简单分析一下运行结果。</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>, p1线程向缓冲中写入<span class="number">1</span>。    此时，缓冲区数据:   | <span class="number">1</span> |   |   |   |   |</span><br><span class="line">     <span class="number">2</span>, p4线程向缓冲中写入<span class="number">4</span>。    此时，缓冲区数据:   | <span class="number">1</span> | <span class="number">4</span> |   |   |   |</span><br><span class="line">     <span class="number">3</span>, p5线程向缓冲中写入<span class="number">5</span>。    此时，缓冲区数据:   | <span class="number">1</span> | <span class="number">4</span> | <span class="number">5</span> |   |   |</span><br><span class="line">     <span class="number">4</span>, p0线程向缓冲中写入<span class="number">0</span>。    此时，缓冲区数据:   | <span class="number">1</span> | <span class="number">4</span> | <span class="number">5</span> | <span class="number">0</span> |   |</span><br><span class="line">     <span class="number">5</span>, p2线程向缓冲中写入<span class="number">2</span>。    此时，缓冲区数据:   | <span class="number">1</span> | <span class="number">4</span> | <span class="number">5</span> | <span class="number">0</span> | <span class="number">2</span> |</span><br><span class="line">     此时，缓冲区容量为<span class="number">5</span>；缓冲区已满！如果此时，还有“写线程”想往缓冲中写入数据，会调用put中的notFull.await()等待，直接缓冲区非满状态，才能继续运行。</span><br><span class="line">     <span class="number">6</span>, t0线程从缓冲中取出数据<span class="number">1</span>。此时，缓冲区数据:   |   | <span class="number">4</span> | <span class="number">5</span> | <span class="number">0</span> | <span class="number">2</span> |</span><br><span class="line">     <span class="number">7</span>, p3线程向缓冲中写入<span class="number">3</span>。    此时，缓冲区数据:   | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span> | <span class="number">0</span> | <span class="number">2</span> |</span><br><span class="line">     <span class="number">8</span>, t1线程从缓冲中取出数据<span class="number">4</span>。此时，缓冲区数据:   | <span class="number">3</span> |   | <span class="number">5</span> | <span class="number">0</span> | <span class="number">2</span> |</span><br><span class="line">     <span class="number">9</span>, p6线程向缓冲中写入<span class="number">6</span>。    此时，缓冲区数据:   | <span class="number">3</span> | <span class="number">6</span> | <span class="number">5</span> | <span class="number">0</span> | <span class="number">2</span> |</span><br><span class="line">     ...</span><br></pre></td></tr></table></figure>
<h1 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。 </span><br><span class="line">LockSupport中的park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程，而且park()和unpark()不会遇到“Thread.suspend 和 Thread.resume所可能引发的死锁”问题。</span><br><span class="line">因为park() 和 unpark()有许可的存在；调用 park() 的线程和另一个试图将其 unpark() 的线程之间的竞争将保持活性。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LockSupport函数列表</span></span><br><span class="line"><span class="comment">// 返回提供给最近一次尚未解除阻塞的 park 方法调用的 blocker 对象，如果该调用不受阻塞，则返回 null。</span></span><br><span class="line"><span class="keyword">static</span> Object <span class="title function_">getBlocker</span><span class="params">(Thread t)</span></span><br><span class="line"><span class="comment">// 为了线程调度，禁用当前线程，除非许可可用。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 为了线程调度，在许可可用之前禁用当前线程。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">(Object blocker)</span></span><br><span class="line"><span class="comment">// 为了线程调度禁用当前线程，最多等待指定的等待时间，除非许可可用。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parkNanos</span><span class="params">(<span class="type">long</span> nanos)</span></span><br><span class="line"><span class="comment">// 为了线程调度，在许可可用前禁用当前线程，并最多等待指定的等待时间。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parkNanos</span><span class="params">(Object blocker, <span class="type">long</span> nanos)</span></span><br><span class="line"><span class="comment">// 为了线程调度，在指定的时限前禁用当前线程，除非许可可用。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parkUntil</span><span class="params">(<span class="type">long</span> deadline)</span></span><br><span class="line"><span class="comment">// 为了线程调度，在指定的时限前禁用当前线程，除非许可可用。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parkUntil</span><span class="params">(Object blocker, <span class="type">long</span> deadline)</span></span><br><span class="line"><span class="comment">// 如果给定线程的许可尚不可用，则使其可用。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Thread thread)</span></span><br></pre></td></tr></table></figure>
<h2 id="LockSupport示例"><a href="#LockSupport示例" class="headerlink" title="LockSupport示例"></a>LockSupport示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class WaitTest1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadA ta = new ThreadA(&quot;ta&quot;);</span><br><span class="line">        synchronized(ta) &#123; // 通过synchronized(ta)获取“对象ta的同步锁”</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot; start ta&quot;);</span><br><span class="line">                ta.start();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot; block&quot;);</span><br><span class="line">                // 主线程等待</span><br><span class="line">                ta.wait();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot; continue&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class ThreadA extends Thread&#123;</span><br><span class="line">        public ThreadA(String name) &#123;</span><br><span class="line">            super(name);</span><br><span class="line">        &#125;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (this) &#123; // 通过synchronized(this)获取“当前对象的同步锁”</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot; wakup others&quot;);</span><br><span class="line">                notify();    // 唤醒“当前对象上的等待线程”</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSupportTest1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread mainThread;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadA</span> <span class="variable">ta</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>(<span class="string">&quot;ta&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取主线程</span></span><br><span class="line">        mainThread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; start ta&quot;</span>);</span><br><span class="line">        ta.start();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; block&quot;</span>);</span><br><span class="line">        <span class="comment">// 主线程阻塞</span></span><br><span class="line">        LockSupport.park(mainThread);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; continue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ThreadA</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; wakup others&quot;</span>);</span><br><span class="line">            <span class="comment">// 唤醒“主线程”</span></span><br><span class="line">            LockSupport.unpark(mainThread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">main start ta</span><br><span class="line">main block</span><br><span class="line">ta wakup others</span><br><span class="line">main <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">说明：park和wait的区别。wait让线程阻塞前，必须通过<span class="keyword">synchronized</span>获取同步锁。</span><br></pre></td></tr></table></figure>
<h1 id="共享锁和ReentrantReadWriteLock"><a href="#共享锁和ReentrantReadWriteLock" class="headerlink" title="共享锁和ReentrantReadWriteLock"></a>共享锁和ReentrantReadWriteLock</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ReadWriteLock，顾名思义，是读写锁。它维护了一对相关的锁 — — “读取锁”和“写入锁”，一个用于读取操作，另一个用于写入操作。</span><br><span class="line">“读取锁”用于只读操作，它是“共享锁”，能同时被多个线程获取。</span><br><span class="line">“写入锁”用于写入操作，它是“独占锁”，写入锁只能被一个线程锁获取。</span><br><span class="line">注意：不能同时存在读取锁和写入锁！</span><br><span class="line">ReadWriteLock是一个接口。ReentrantReadWriteLock是它的实现类，ReentrantReadWriteLock包括子类ReadLock和WriteLock。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ReadWriteLock函数列表</span><br><span class="line">// 返回用于读取操作的锁。</span><br><span class="line">Lock readLock()</span><br><span class="line">// 返回用于写入操作的锁。</span><br><span class="line">Lock writeLock()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// ReentrantReadWriteLock函数列表</span><br><span class="line">// 创建一个新的 ReentrantReadWriteLock，默认是采用“非公平策略”。</span><br><span class="line">ReentrantReadWriteLock()</span><br><span class="line">// 创建一个新的 ReentrantReadWriteLock，fair是“公平策略”。fair为true，意味着公平策略；否则，意味着非公平策略。</span><br><span class="line">ReentrantReadWriteLock(boolean fair)</span><br><span class="line">// 返回当前拥有写入锁的线程，如果没有这样的线程，则返回 null。</span><br><span class="line">protected Thread getOwner()</span><br><span class="line">// 返回一个 collection，它包含可能正在等待获取读取锁的线程。</span><br><span class="line">protected Collection&lt;Thread&gt; getQueuedReaderThreads()</span><br><span class="line">// 返回一个 collection，它包含可能正在等待获取读取或写入锁的线程。</span><br><span class="line">protected Collection&lt;Thread&gt; getQueuedThreads()</span><br><span class="line">// 返回一个 collection，它包含可能正在等待获取写入锁的线程。</span><br><span class="line">protected Collection&lt;Thread&gt; getQueuedWriterThreads()</span><br><span class="line">// 返回等待获取读取或写入锁的线程估计数目。</span><br><span class="line">int getQueueLength()</span><br><span class="line">// 查询当前线程在此锁上保持的重入读取锁数量。</span><br><span class="line">int getReadHoldCount()</span><br><span class="line">// 查询为此锁保持的读取锁数量。</span><br><span class="line">int getReadLockCount()</span><br><span class="line">// 返回一个 collection，它包含可能正在等待与写入锁相关的给定条件的那些线程。</span><br><span class="line">protected Collection&lt;Thread&gt; getWaitingThreads(Condition condition)</span><br><span class="line">// 返回正等待与写入锁相关的给定条件的线程估计数目。</span><br><span class="line">int getWaitQueueLength(Condition condition)</span><br><span class="line">// 查询当前线程在此锁上保持的重入写入锁数量。</span><br><span class="line">int getWriteHoldCount()</span><br><span class="line">// 查询是否给定线程正在等待获取读取或写入锁。</span><br><span class="line">boolean hasQueuedThread(Thread thread)</span><br><span class="line">// 查询是否所有的线程正在等待获取读取或写入锁。</span><br><span class="line">boolean hasQueuedThreads()</span><br><span class="line">// 查询是否有些线程正在等待与写入锁有关的给定条件。</span><br><span class="line">boolean hasWaiters(Condition condition)</span><br><span class="line">// 如果此锁将公平性设置为 ture，则返回 true。</span><br><span class="line">boolean isFair()</span><br><span class="line">// 查询是否某个线程保持了写入锁。</span><br><span class="line">boolean isWriteLocked()</span><br><span class="line">// 查询当前线程是否保持了写入锁。</span><br><span class="line">boolean isWriteLockedByCurrentThread()</span><br><span class="line">// 返回用于读取操作的锁。</span><br><span class="line">ReentrantReadWriteLock.ReadLock readLock()</span><br><span class="line">// 返回用于写入操作的锁。</span><br><span class="line">ReentrantReadWriteLock.WriteLock writeLock()</span><br></pre></td></tr></table></figure>
<h2 id="获取共享锁"><a href="#获取共享锁" class="headerlink" title="获取共享锁"></a>获取共享锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">获取共享锁的思想(即lock函数的步骤)，是先通过tryAcquireShared()尝试获取共享锁。尝试成功的话，则直接返回；尝试失败的话，则通过doAcquireShared()不断的循环并尝试获取锁，若有需要，则阻塞等待。doAcquireShared()在循环中每次尝试获取锁时，都是通过tryAcquireShared()来进行尝试的。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> lock()</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> acquireShared()</span><br><span class="line">说明：acquireShared()首先会通过tryAcquireShared()来尝试获取锁。</span><br><span class="line">尝试成功的话，则不再做任何动作(因为已经成功获取到锁了)。</span><br><span class="line">尝试失败的话，则通过doAcquireShared()来获取锁。doAcquireShared()会获取到锁了才返回。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> tryAcquireShared()</span><br><span class="line">说明：tryAcquireShared()的作用是尝试获取“共享锁”。</span><br><span class="line">如果在尝试获取锁时，“不需要阻塞等待”并且“读取锁的共享计数小于MAX_COUNT”，则直接通过CAS函数更新“读取锁的共享计数”，以及将“当前线程获取读取锁的次数+<span class="number">1</span>”。</span><br><span class="line">否则，通过fullTryAcquireShared()获取读取锁。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> fullTryAcquireShared()</span><br><span class="line">说明：fullTryAcquireShared()会根据“是否需要阻塞等待”，“读取锁的共享计数是否超过限制”等等进行处理。如果不需要阻塞等待，并且锁的共享计数没有超过限制，则通过CAS尝试获取锁，并返回<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> doAcquireShared()</span><br><span class="line">说明：doAcquireShared()的作用是获取共享锁。</span><br><span class="line">它会首先创建线程对应的CLH队列的节点，然后将该节点添加到CLH队列中。CLH队列是管理获取锁的等待线程的队列。</span><br><span class="line">如果“当前线程”是CLH队列的表头，则尝试获取共享锁；否则，则需要通过shouldParkAfterFailedAcquire()判断是否阻塞等待，需要的话，则通过parkAndCheckInterrupt()进行阻塞等待。</span><br><span class="line">doAcquireShared()会通过<span class="keyword">for</span>循环，不断的进行上面的操作；目的就是获取共享锁。需要注意的是：doAcquireShared()在每一次尝试获取锁时，是通过tryAcquireShared()来执行的！</span><br></pre></td></tr></table></figure>
<h2 id="释放共享锁"><a href="#释放共享锁" class="headerlink" title="释放共享锁"></a>释放共享锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">释放共享锁的思想，是先通过tryReleaseShared()尝试释放共享锁。尝试成功的话，则通过doReleaseShared()唤醒“其他等待获取共享锁的线程”，并返回<span class="literal">true</span>；否则的话，返回flase。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> unlock()</span><br><span class="line">说明：该函数实际上调用releaseShared(<span class="number">1</span>)释放共享锁。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> releaseShared()</span><br><span class="line">说明：releaseShared()的目的是让当前线程释放它所持有的共享锁。</span><br><span class="line">它首先会通过tryReleaseShared()去尝试释放共享锁。尝试成功，则直接返回；尝试失败，则通过doReleaseShared()去释放共享锁。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> tryReleaseShared()</span><br><span class="line">说明：tryReleaseShared()的作用是尝试释放共享锁。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> doReleaseShared()</span><br><span class="line">说明：doReleaseShared()会释放“共享锁”。它会从前往后的遍历CLH队列，依次“唤醒”然后“执行”队列中每个节点对应的线程；最终的目的是让这些线程释放它们所持有的锁。</span><br></pre></td></tr></table></figure>
<h2 id="公平共享锁和非公平共享锁"><a href="#公平共享锁和非公平共享锁" class="headerlink" title="公平共享锁和非公平共享锁"></a>公平共享锁和非公平共享锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">和互斥锁ReentrantLock一样，ReadLock也分为公平锁和非公平锁。</span><br><span class="line"></span><br><span class="line">公平锁和非公平锁的区别，体现在判断是否需要阻塞的函数readerShouldBlock()是不同的。</span><br><span class="line">在公平共享锁中，如果在当前线程的前面有其他线程在等待获取共享锁，则返回<span class="literal">true</span>；否则，返回<span class="literal">false</span>。</span><br><span class="line">在非公平共享锁中，它会无视当前线程的前面是否有其他线程在等待获取共享锁。只要该非公平共享锁对应的线程不为<span class="literal">null</span>，则返回<span class="literal">true</span>。</span><br></pre></td></tr></table></figure>
<h2 id="ReentrantReadWriteLock示例"><a href="#ReentrantReadWriteLock示例" class="headerlink" title="ReentrantReadWriteLock示例"></a>ReentrantReadWriteLock示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockTest1</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        <span class="comment">// 创建账户</span></span><br><span class="line">        <span class="type">MyCount</span> <span class="variable">myCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCount</span>(<span class="string">&quot;4238920615242830&quot;</span>, <span class="number">10000</span>); </span><br><span class="line">        <span class="comment">// 创建用户，并指定账户</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tommy&quot;</span>, myCount); </span><br><span class="line">        <span class="comment">// 分别启动3个“读取账户金钱”的线程 和 3个“设置账户金钱”的线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">            user.getCash();</span><br><span class="line">            user.setCash((i+<span class="number">1</span>)*<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;            <span class="comment">//用户名 </span></span><br><span class="line">    <span class="keyword">private</span> MyCount myCount;        <span class="comment">//所要操作的账户 </span></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock myLock;   <span class="comment">//执行操作所需的锁对象 </span></span><br><span class="line">    User(String name, MyCount myCount) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name; </span><br><span class="line">        <span class="built_in">this</span>.myCount = myCount; </span><br><span class="line">        <span class="built_in">this</span>.myLock = <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getCash</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                myLock.readLock().lock(); </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() +<span class="string">&quot; getCash start&quot;</span>); </span><br><span class="line">                    myCount.getCash();</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() +<span class="string">&quot; getCash end&quot;</span>); </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    myLock.readLock().unlock(); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCash</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> cash)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                myLock.writeLock().lock(); </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() +<span class="string">&quot; setCash start&quot;</span>); </span><br><span class="line">                    myCount.setCash(cash);</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() +<span class="string">&quot; setCash end&quot;</span>); </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    myLock.writeLock().unlock(); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCount</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;         <span class="comment">//账号 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>    cash;       <span class="comment">//账户余额 </span></span><br><span class="line">    MyCount(String id, <span class="type">int</span> cash) &#123; </span><br><span class="line">        <span class="built_in">this</span>.id = id; </span><br><span class="line">        <span class="built_in">this</span>.cash = cash; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> id; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.id = id; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCash</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(Thread.currentThread().getName() +<span class="string">&quot; getCash cash=&quot;</span>+ cash); </span><br><span class="line">        <span class="keyword">return</span> cash; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCash</span><span class="params">(<span class="type">int</span> cash)</span> &#123; </span><br><span class="line">        System.out.println(Thread.currentThread().getName() +<span class="string">&quot; setCash cash=&quot;</span>+ cash); </span><br><span class="line">        <span class="built_in">this</span>.cash = cash; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread-<span class="number">0</span> getCash start</span><br><span class="line">Thread-<span class="number">2</span> getCash start</span><br><span class="line">Thread-<span class="number">0</span> getCash cash=<span class="number">10000</span></span><br><span class="line">Thread-<span class="number">2</span> getCash cash=<span class="number">10000</span></span><br><span class="line">Thread-<span class="number">0</span> getCash end</span><br><span class="line">Thread-<span class="number">2</span> getCash end</span><br><span class="line">Thread-<span class="number">1</span> setCash start</span><br><span class="line">Thread-<span class="number">1</span> setCash cash=<span class="number">1000</span></span><br><span class="line">Thread-<span class="number">1</span> setCash end</span><br><span class="line">Thread-<span class="number">3</span> setCash start</span><br><span class="line">Thread-<span class="number">3</span> setCash cash=<span class="number">2000</span></span><br><span class="line">Thread-<span class="number">3</span> setCash end</span><br><span class="line">Thread-<span class="number">4</span> getCash start</span><br><span class="line">Thread-<span class="number">4</span> getCash cash=<span class="number">2000</span></span><br><span class="line">Thread-<span class="number">4</span> getCash end</span><br><span class="line">Thread-<span class="number">5</span> setCash start</span><br><span class="line">Thread-<span class="number">5</span> setCash cash=<span class="number">3000</span></span><br><span class="line">Thread-<span class="number">5</span> setCash end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果说明：</span><br><span class="line">(<span class="number">01</span>) 观察Thread0和Thread-<span class="number">2</span>的运行结果，我们发现，Thread-<span class="number">0</span>启动并获取到“读取锁”，在它还没运行完毕的时候，Thread-<span class="number">2</span>也启动了并且也成功获取到“读取锁”。</span><br><span class="line">因此，“读取锁”支持被多个线程同时获取。</span><br><span class="line">(<span class="number">02</span>) 观察Thread-<span class="number">1</span>,Thread-<span class="number">3</span>,Thread-<span class="number">5</span>这三个“写入锁”的线程。只要“写入锁”被某线程获取，则该线程运行完毕了，才释放该锁。</span><br><span class="line">因此，“写入锁”不支持被多个线程同时获取。</span><br></pre></td></tr></table></figure>
<h1 id="CountDownLatch原理和示例"><a href="#CountDownLatch原理和示例" class="headerlink" title="CountDownLatch原理和示例"></a>CountDownLatch原理和示例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。</span><br><span class="line">CountDownLatch和CyclicBarrier的区别</span><br><span class="line">(<span class="number">01</span>) CountDownLatch的作用是允许<span class="number">1</span>或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待。</span><br><span class="line">(<span class="number">02</span>) CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。</span><br><span class="line">关于CyclicBarrier的原理，后面一章再来学习。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CountDownLatch函数列表</span></span><br><span class="line">CountDownLatch(<span class="type">int</span> count)</span><br><span class="line"><span class="comment">// 构造一个用给定计数初始化的 CountDownLatch。</span></span><br><span class="line"><span class="comment">// 使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断或超出了指定的等待时间。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line"><span class="comment">// 递减锁存器的计数，如果计数到达零，则释放所有等待的线程。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 返回当前计数。</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">getCount</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 返回标识此锁存器及其状态的字符串。</span></span><br><span class="line">String <span class="title function_">toString</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> CountDownLatch(<span class="type">int</span> count)</span><br><span class="line">说明：该函数是创建一个Sync对象，而Sync是继承于AQS类。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> await()</span><br><span class="line">说明：该函数实际上是调用的AQS的acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">说明：acquireSharedInterruptibly()的作用是获取共享锁。</span><br><span class="line">如果当前线程是中断状态，则抛出异常InterruptedException。否则，调用tryAcquireShared(arg)尝试获取共享锁；尝试成功则返回，否则就调用doAcquireSharedInterruptibly()。doAcquireSharedInterruptibly()会使当前线程一直等待，直到当前线程获取到共享锁(或被中断)才返回。</span><br><span class="line">说明：tryAcquireShared()的作用是尝试获取共享锁。</span><br><span class="line">如果<span class="string">&quot;锁计数器=0&quot;</span>，即锁是可获取状态，则返回<span class="number">1</span>；否则，锁是不可获取状态，则返回-<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">(<span class="number">01</span>) addWaiter(Node.SHARED)的作用是，创建”当前线程“的Node节点，且Node中记录的锁的类型是”共享锁“(Node.SHARED)；并将该节点添加到CLH队列末尾。关于Node和CLH在<span class="string">&quot;Java多线程系列--“JUC锁”03之 公平锁(一)&quot;</span>已经详细介绍过，这里就不再重复说明了。</span><br><span class="line">(<span class="number">02</span>) node.predecessor()的作用是，获取上一个节点。如果上一节点是CLH队列的表头，则”尝试获取共享锁“。</span><br><span class="line">(<span class="number">03</span>) shouldParkAfterFailedAcquire()的作用和它的名称一样，如果在尝试获取锁失败之后，线程应该等待，则返回<span class="literal">true</span>；否则，返回<span class="literal">false</span>。</span><br><span class="line">(<span class="number">04</span>) 当shouldParkAfterFailedAcquire()返回ture时，则调用parkAndCheckInterrupt()，当前线程会进入等待状态，直到获取到共享锁才继续运行。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> countDown()</span><br><span class="line">说明：该函数实际上调用releaseShared(<span class="number">1</span>)释放共享锁。</span><br><span class="line">说明：releaseShared()的目的是让当前线程释放它所持有的共享锁。</span><br><span class="line">它首先会通过tryReleaseShared()去尝试释放共享锁。尝试成功，则直接返回；尝试失败，则通过doReleaseShared()去释放共享锁。</span><br><span class="line">说明：tryReleaseShared()的作用是释放共享锁，将“锁计数器”的值-<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">总结：CountDownLatch是通过“共享锁”实现的。在创建CountDownLatch中时，会传递一个<span class="type">int</span>类型参数count，该参数是“锁计数器”的初始状态，表示该“共享锁”最多能被count给线程同时获取。当某线程调用该CountDownLatch对象的await()方法时，该线程会等待“共享锁”可用时，才能获取“共享锁”进而继续运行。而“共享锁”可用的条件，就是“锁计数器”的值为<span class="number">0</span>！而“锁计数器”的初始值为count，每当一个线程调用该CountDownLatch对象的countDown()方法时，才将“锁计数器”-<span class="number">1</span>；通过这种方式，必须有count个线程调用countDown()之后，“锁计数器”才为<span class="number">0</span>，而前面提到的等待线程才能继续运行！</span><br></pre></td></tr></table></figure>
<h2 id="CountDownLatch的使用示例"><a href="#CountDownLatch的使用示例" class="headerlink" title="CountDownLatch的使用示例"></a>CountDownLatch的使用示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过CountDownLatch实现：&quot;主线程&quot;等待&quot;5个子线程&quot;全部都完成&quot;指定的工作(休眠1000ms)&quot;之后，再继续运行。</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchTest1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">LATCH_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch doneSignal;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doneSignal = <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(LATCH_SIZE);</span><br><span class="line">            <span class="comment">// 新建5个任务</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;LATCH_SIZE; i++)</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InnerThread</span>().start();</span><br><span class="line">            System.out.println(<span class="string">&quot;main await begin.&quot;</span>);</span><br><span class="line">            <span class="comment">// &quot;主线程&quot;等待线程池中5个任务的完成</span></span><br><span class="line">            doneSignal.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;main await finished.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sleep 1000ms.&quot;</span>);</span><br><span class="line">                <span class="comment">// 将CountDownLatch的数值减1</span></span><br><span class="line">                doneSignal.countDown();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main await begin.</span><br><span class="line">Thread-<span class="number">0</span> sleep 1000ms.</span><br><span class="line">Thread-<span class="number">2</span> sleep 1000ms.</span><br><span class="line">Thread-<span class="number">1</span> sleep 1000ms.</span><br><span class="line">Thread-<span class="number">4</span> sleep 1000ms.</span><br><span class="line">Thread-<span class="number">3</span> sleep 1000ms.</span><br><span class="line">main await finished.</span><br><span class="line">    </span><br><span class="line">结果说明：主线程通过doneSignal.await()等待其它线程将doneSignal递减至<span class="number">0</span>。其它的<span class="number">5</span>个InnerThread线程，每一个都通过doneSignal.countDown()将doneSignal的值减<span class="number">1</span>；当doneSignal为<span class="number">0</span>时，main被唤醒后继续执行。</span><br></pre></td></tr></table></figure>
<h1 id="CyclicBarrier原理和示例"><a href="#CyclicBarrier原理和示例" class="headerlink" title="CyclicBarrier原理和示例"></a>CyclicBarrier原理和示例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CyclicBarrier是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。</span><br><span class="line">注意比较CountDownLatch和CyclicBarrier：</span><br><span class="line">(<span class="number">01</span>) CountDownLatch的作用是允许<span class="number">1</span>或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待。</span><br><span class="line">(<span class="number">02</span>) CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CyclicBarrier函数列表</span></span><br><span class="line">CyclicBarrier(<span class="type">int</span> parties)</span><br><span class="line"><span class="comment">// 创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，但它不会在启动 barrier 时执行预定义的操作。</span></span><br><span class="line">CyclicBarrier(<span class="type">int</span> parties, Runnable barrierAction)</span><br><span class="line"><span class="comment">// 创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，并在启动 barrier 时执行给定的屏障操作，该操作由最后一个进入 barrier 的线程执行。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">await</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line"><span class="comment">// 在所有参与者都已经在此屏障上调用 await 方法之前将一直等待,或者超出了指定的等待时间。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getNumberWaiting</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 返回当前在屏障处等待的参与者数目。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getParties</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 返回要求启动此 barrier 的参与者数目。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isBroken</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 查询此屏障是否处于损坏状态。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 将屏障重置为其初始状态。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 构造函数</span><br><span class="line">CyclicBarrier的构造函数共<span class="number">2</span>个：CyclicBarrier 和 CyclicBarrier(<span class="type">int</span> parties, Runnable barrierAction)。第<span class="number">1</span>个构造函数是调用第<span class="number">2</span>个构造函数来实现的，</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 等待函数</span><br><span class="line">说明：await()是通过dowait()实现的。</span><br><span class="line">说明：dowait()的作用就是让当前线程阻塞，直到“有parties个线程到达barrier” 或 “当前线程被中断” 或 “超时”这<span class="number">3</span>者之一发生，当前线程才继续执行。</span><br><span class="line">(<span class="number">01</span>) generation是CyclicBarrier的一个成员遍历，它的定义如下：</span><br><span class="line"><span class="keyword">private</span> <span class="type">Generation</span> <span class="variable">generation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Generation</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Generation</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">broken</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">在CyclicBarrier中，同一批的线程属于同一代，即同一个Generation；CyclicBarrier中通过generation对象，记录属于哪一代。</span><br><span class="line">当有parties个线程到达barrier，generation就会被更新换代。</span><br><span class="line">(<span class="number">02</span>) 如果当前线程被中断，即Thread.interrupted()为<span class="literal">true</span>；则通过breakBarrier()终止CyclicBarrier。breakBarrier()的源码如下：</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">breakBarrier</span><span class="params">()</span> &#123;</span><br><span class="line">    generation.broken = <span class="literal">true</span>;</span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br><span class="line">breakBarrier()会设置当前中断标记broken为<span class="literal">true</span>，意味着“将该Generation中断”；同时，设置count=parties，即重新初始化count；最后，通过signalAll()唤醒CyclicBarrier上所有的等待线程。</span><br><span class="line">(<span class="number">03</span>) 将“count计数器”-<span class="number">1</span>，即--count；然后判断是不是“有parties个线程到达barrier”，即index是不是为<span class="number">0</span>。</span><br><span class="line">当index=<span class="number">0</span>时，如果barrierCommand不为<span class="literal">null</span>，则执行该barrierCommand，barrierCommand就是我们创建CyclicBarrier时，传入的Runnable对象。然后，调用nextGeneration()进行换代工作，nextGeneration()的源码如下：</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">nextGeneration</span><span class="params">()</span> &#123;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> <span class="title class_">Generation</span>();</span><br><span class="line">&#125;</span><br><span class="line">首先，它会调用signalAll()唤醒CyclicBarrier上所有的等待线程；接着，重新初始化count；最后，更新generation的值。</span><br><span class="line">(<span class="number">04</span>) 在<span class="keyword">for</span>(;;)循环中。timed是用来表示当前是不是“超时等待”线程。如果不是，则通过trip.await()进行等待；否则，调用awaitNanos()进行超时等待。</span><br></pre></td></tr></table></figure>
<h2 id="CyclicBarrier的使用示例"><a href="#CyclicBarrier的使用示例" class="headerlink" title="CyclicBarrier的使用示例"></a>CyclicBarrier的使用示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建5个线程，这5个线程达到一定的条件时，它们才继续往后运行。</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cb;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        cb = <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(SIZE);</span><br><span class="line">        <span class="comment">// 新建5个任务</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;SIZE; i++)</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InnerThread</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; wait for CyclicBarrier.&quot;</span>);</span><br><span class="line">                <span class="comment">// 将cb的参与者数量加1</span></span><br><span class="line">                cb.await();</span><br><span class="line">                <span class="comment">// cb的参与者数量等于5时，才继续往后执行</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; continued.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread-<span class="number">1</span> wait <span class="keyword">for</span> CyclicBarrier.</span><br><span class="line">Thread-<span class="number">2</span> wait <span class="keyword">for</span> CyclicBarrier.</span><br><span class="line">Thread-<span class="number">3</span> wait <span class="keyword">for</span> CyclicBarrier.</span><br><span class="line">Thread-<span class="number">4</span> wait <span class="keyword">for</span> CyclicBarrier.</span><br><span class="line">Thread-<span class="number">0</span> wait <span class="keyword">for</span> CyclicBarrier.</span><br><span class="line">Thread-<span class="number">0</span> continued.</span><br><span class="line">Thread-<span class="number">4</span> continued.</span><br><span class="line">Thread-<span class="number">2</span> continued.</span><br><span class="line">Thread-<span class="number">3</span> continued.</span><br><span class="line">Thread-<span class="number">1</span> continued.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果说明：主线程中新建了<span class="number">5</span>个线程，所有的这些线程都调用cb.await()等待。所有这些线程一直等待，直到cb中所有线程都达到barrier时，这些线程才继续运行！</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建5个线程，当这5个线程达到一定的条件时，执行某项任务。</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cb;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        cb = <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(SIZE, <span class="keyword">new</span> <span class="title class_">Runnable</span> () &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;CyclicBarrier&#x27;s parties is: &quot;</span>+ cb.getParties());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 新建5个任务</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;SIZE; i++)</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InnerThread</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; wait for CyclicBarrier.&quot;</span>);</span><br><span class="line">                <span class="comment">// 将cb的参与者数量加1</span></span><br><span class="line">                cb.await();</span><br><span class="line">                <span class="comment">// cb的参与者数量等于5时，才继续往后执行</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; continued.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread-<span class="number">1</span> wait <span class="keyword">for</span> CyclicBarrier.</span><br><span class="line">Thread-<span class="number">2</span> wait <span class="keyword">for</span> CyclicBarrier.</span><br><span class="line">Thread-<span class="number">3</span> wait <span class="keyword">for</span> CyclicBarrier.</span><br><span class="line">Thread-<span class="number">4</span> wait <span class="keyword">for</span> CyclicBarrier.</span><br><span class="line">Thread-<span class="number">0</span> wait <span class="keyword">for</span> CyclicBarrier.</span><br><span class="line">CyclicBarrier<span class="string">&#x27;s parties is: 5</span></span><br><span class="line"><span class="string">Thread-0 continued.</span></span><br><span class="line"><span class="string">Thread-4 continued.</span></span><br><span class="line"><span class="string">Thread-2 continued.</span></span><br><span class="line"><span class="string">Thread-3 continued.</span></span><br><span class="line"><span class="string">Thread-1 continued.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">结果说明：主线程中新建了5个线程，所有的这些线程都调用cb.await()等待。所有这些线程一直等待，直到cb中所有线程都达到barrier时，执行新建cb时注册的Runnable任务。</span></span><br></pre></td></tr></table></figure>
<h1 id="Semaphore信号量的原理和示例"><a href="#Semaphore信号量的原理和示例" class="headerlink" title="Semaphore信号量的原理和示例"></a>Semaphore信号量的原理和示例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Semaphore是一个计数信号量，它的本质是一个<span class="string">&quot;共享锁&quot;</span>。</span><br><span class="line"></span><br><span class="line">信号量维护了一个信号量许可集。线程可以通过调用acquire()来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须等待，直到有可用的许可为止。 线程可以通过release()来释放它所持有的信号量许可。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Semaphore的函数列表</span></span><br><span class="line"><span class="comment">// 创建具有给定的许可数和非公平的公平设置的 Semaphore。</span></span><br><span class="line">Semaphore(<span class="type">int</span> permits)</span><br><span class="line"><span class="comment">// 创建具有给定的许可数和给定的公平设置的 Semaphore。</span></span><br><span class="line">Semaphore(<span class="type">int</span> permits, <span class="type">boolean</span> fair)</span><br><span class="line"><span class="comment">// 从此信号量获取一个许可，在提供一个许可前一直将线程阻塞，否则线程被中断。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 从此信号量获取给定数目的许可，在提供这些许可前一直将线程阻塞，或者线程已被中断。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> permits)</span></span><br><span class="line"><span class="comment">// 从此信号量中获取许可，在有可用的许可前将其阻塞。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">acquireUninterruptibly</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 从此信号量获取给定数目的许可，在提供这些许可前一直将线程阻塞。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">acquireUninterruptibly</span><span class="params">(<span class="type">int</span> permits)</span></span><br><span class="line"><span class="comment">// 返回此信号量中当前可用的许可数。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">availablePermits</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 获取并返回立即可用的所有许可。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">drainPermits</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 返回一个 collection，包含可能等待获取的线程。</span></span><br><span class="line"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title function_">getQueuedThreads</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 返回正在等待获取的线程的估计数目。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getQueueLength</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 查询是否有线程正在等待获取。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">hasQueuedThreads</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 如果此信号量的公平设置为 true，则返回 true。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isFair</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 根据指定的缩减量减小可用许可的数目。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">reducePermits</span><span class="params">(<span class="type">int</span> reduction)</span></span><br><span class="line"><span class="comment">// 释放一个许可，将其返回给信号量。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 释放给定数目的许可，将其返回到信号量。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> permits)</span></span><br><span class="line"><span class="comment">// 返回标识此信号量的字符串，以及信号量的状态。</span></span><br><span class="line">String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 仅在调用时此信号量存在一个可用许可，才从信号量获取许可。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 仅在调用时此信号量中有给定数目的许可时，才从此信号量中获取这些许可。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> permits)</span></span><br><span class="line"><span class="comment">// 如果在给定的等待时间内此信号量有可用的所有许可，并且当前线程未被中断，则从此信号量获取给定数目的许可。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> permits, <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line"><span class="comment">// 如果在给定的等待时间内，此信号量有可用的许可并且当前线程未被中断，则从此信号量获取一个许可。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Semaphore是通过共享锁实现的。根据共享锁的获取原则，Semaphore分为<span class="string">&quot;公平信号量&quot;</span>和<span class="string">&quot;非公平信号量&quot;</span>。</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;公平信号量&quot;</span>和<span class="string">&quot;非公平信号量&quot;</span>的区别</span><br><span class="line"><span class="string">&quot;公平信号量&quot;</span>和<span class="string">&quot;非公平信号量&quot;</span>的释放信号量的机制是一样的！不同的是它们获取信号量的机制：线程在尝试获取信号量许可时，对于公平信号量而言，如果当前线程不在CLH队列的头部，则排队等候；而对于非公平信号量而言，无论当前线程是不是在CLH队列的头部，它都会直接获取信号量。该差异具体的体现在，它们的tryAcquireShared()函数的实现不同。</span><br></pre></td></tr></table></figure>
<h2 id="公平信号量获取和释放"><a href="#公平信号量获取和释放" class="headerlink" title="公平信号量获取和释放"></a>公平信号量获取和释放</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 公平信号量的获取</span><br><span class="line">Semaphore中的公平信号量是FairSync。</span><br><span class="line">信号量中的acquire()获取函数，实际上是调用的AQS中的acquireSharedInterruptibly()。</span><br><span class="line">说明：tryAcquireShared()的作用是尝试获取acquires个信号量许可数。</span><br><span class="line">对于Semaphore而言，state表示的是“当前可获得的信号量许可数”。</span><br><span class="line">说明：doAcquireSharedInterruptibly()会使当前线程一直等待，直到当前线程获取到共享锁(或被中断)才返回。</span><br><span class="line">(<span class="number">01</span>) addWaiter(Node.SHARED)的作用是，创建”当前线程“的Node节点，且Node中记录的锁的类型是”共享锁“(Node.SHARED)；并将该节点添加到CLH队列末尾。关于Node和CLH在<span class="string">&quot;Java多线程系列--“JUC锁”03之 公平锁(一)&quot;</span>已经详细介绍过，这里就不再重复说明了。</span><br><span class="line">(<span class="number">02</span>) node.predecessor()的作用是，获取上一个节点。如果上一节点是CLH队列的表头，则”尝试获取共享锁“。</span><br><span class="line">(<span class="number">03</span>) shouldParkAfterFailedAcquire()的作用和它的名称一样，如果在尝试获取锁失败之后，线程应该等待，则返回<span class="literal">true</span>；否则，返回<span class="literal">false</span>。</span><br><span class="line">(<span class="number">04</span>) 当shouldParkAfterFailedAcquire()返回ture时，则调用parkAndCheckInterrupt()，当前线程会进入等待状态，直到获取到共享锁才继续运行。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 公平信号量的释放</span><br><span class="line">信号量的releases()释放函数，实际上是调用的AQS中的releaseShared()。</span><br><span class="line">说明：releaseShared()的目的是让当前线程释放它所持有的共享锁。</span><br><span class="line">它首先会通过tryReleaseShared()去尝试释放共享锁。尝试成功，则直接返回；尝试失败，则通过doReleaseShared()去释放共享锁。</span><br><span class="line">Semaphore重写了tryReleaseShared()，</span><br><span class="line">如果tryReleaseShared()尝试释放共享锁失败，则会调用doReleaseShared()去释放共享锁。</span><br><span class="line">说明：doReleaseShared()会释放“共享锁”。它会从前往后的遍历CLH队列，依次“唤醒”然后“执行”队列中每个节点对应的线程；最终的目的是让这些线程释放它们所持有的信号量。</span><br></pre></td></tr></table></figure>
<h2 id="非公平信号量获取和释放"><a href="#非公平信号量获取和释放" class="headerlink" title="非公平信号量获取和释放"></a>非公平信号量获取和释放</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Semaphore中的非公平信号量是NonFairSync。在Semaphore中，“非公平信号量许可的释放(release)”与“公平信号量许可的释放(release)”是一样的。不同的是它们获取“信号量许可”的机制不同，</span><br><span class="line"></span><br><span class="line">说明：非公平信号量的tryAcquireShared()调用AQS中的nonfairTryAcquireShared()。而在nonfairTryAcquireShared()的<span class="keyword">for</span>循环中，它都会直接判断“当前剩余的信号量许可数”是否足够；足够的话，则直接“设置可以获得的信号量许可数”，进而再获取信号量。</span><br><span class="line">而公平信号量的tryAcquireShared()中，在获取信号量之前会通过<span class="keyword">if</span> (hasQueuedPredecessors())来判断“当前线程是不是在CLH队列的头部”，是的话，则返回-<span class="number">1</span>。 </span><br></pre></td></tr></table></figure>
<h2 id="Semaphore示例"><a href="#Semaphore示例" class="headerlink" title="Semaphore示例"></a>Semaphore示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreTest1</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SEM_MAX</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">sem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(SEM_MAX);</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//在线程池中执行任务</span></span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>(sem, <span class="number">5</span>));</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>(sem, <span class="number">4</span>));</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>(sem, <span class="number">7</span>));</span><br><span class="line">        <span class="comment">//关闭池</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Semaphore sem;    <span class="comment">// 信号量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;        <span class="comment">// 申请信号量的大小 </span></span><br><span class="line">    MyThread(Semaphore sem, <span class="type">int</span> count) &#123;</span><br><span class="line">        <span class="built_in">this</span>.sem = sem;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从信号量中获取count个许可</span></span><br><span class="line">            sem.acquire(count);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; acquire count=&quot;</span>+count);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放给定数目的许可，将其返回到信号量。</span></span><br><span class="line">            sem.release(count);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; release &quot;</span> + count + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(某一次)运行结果：</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> acquire count=<span class="number">5</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> acquire count=<span class="number">4</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> release <span class="number">5</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> release <span class="number">4</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> acquire count=<span class="number">7</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> release <span class="number">7</span></span><br><span class="line"></span><br><span class="line">结果说明：信号量sem的许可总数是<span class="number">10</span>个；共<span class="number">3</span>个线程，分别需要获取的信号量许可数是<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>。前面两个线程获取到信号量的许可后，sem中剩余的可用的许可数是<span class="number">1</span>；因此，最后一个线程必须等前两个线程释放了它们所持有的信号量许可之后，才能获取到<span class="number">7</span>个信号量许可。</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/narutohyc">narutohyc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://study.hycbook.com/article/10fd680e.html">https://study.hycbook.com/article/10fd680e.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://study.hycbook.com" target="_blank">兼一书虫</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://pic.hycbook.com/i/hexo/post_cover/蕾姆7.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><link rel="stylesheet" href="/" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">打赏</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://pic.hycbook.com/i//hexo/qr_codes/hyc_wechat.webp" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.hycbook.com/i//hexo/qr_codes/hyc_wechat.webp" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://pic.hycbook.com/i//hexo/qr_codes/hyc_alipay.webp" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.hycbook.com/i//hexo/qr_codes/hyc_alipay.webp" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></button></div><audio id="coinAudio" src="https://s1.vika.cn/space/2022/10/29/6db0ad2bccf949f09054b3b206dcc66f?attname=马里奥游戏投币叮当.mp3"></audio><script defer="defer" src="/"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/article/49959.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.hycbook.com/i//hexo/post_cover/蕾姆3.webp" onerror="onerror=null;src='https://pic.hycbook.com/i/hexo/config_imgs/404.svg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">python异步编程</div></div></a></div><div class="next-post pull-right"><a href="/article/56863.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.hycbook.com/i//hexo/post_cover/蕾姆2.webp" onerror="onerror=null;src='https://pic.hycbook.com/i/hexo/config_imgs/404.svg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">python协程</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Twikoo</span><span class="switch-btn"></span><span class="second-comment">Valine</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JUC%E9%94%81%E9%9B%86%E5%90%88"><span class="toc-number">1.</span> <span class="toc-text">JUC锁集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81ReentrantLock"><span class="toc-number">2.</span> <span class="toc-text">互斥锁ReentrantLock</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">3.</span> <span class="toc-text">公平锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">3.1.</span> <span class="toc-text">获取公平锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tryAcquire"><span class="toc-number">3.2.</span> <span class="toc-text">tryAcquire()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#addWaiter-Node-EXCLUSIVE"><span class="toc-number">3.3.</span> <span class="toc-text">addWaiter(Node.EXCLUSIVE)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#acquireQueued"><span class="toc-number">3.4.</span> <span class="toc-text">acquireQueued()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#selfInterrupt"><span class="toc-number">3.5.</span> <span class="toc-text">selfInterrupt()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">3.6.</span> <span class="toc-text">释放公平锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">4.</span> <span class="toc-text">非公平锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">4.1.</span> <span class="toc-text">获取非公平锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">4.2.</span> <span class="toc-text">释放非公平锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Condition%E6%9D%A1%E4%BB%B6"><span class="toc-number">5.</span> <span class="toc-text">Condition条件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Condition%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.1.</span> <span class="toc-text">Condition示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LockSupport"><span class="toc-number">6.</span> <span class="toc-text">LockSupport</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LockSupport%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.1.</span> <span class="toc-text">LockSupport示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8CReentrantReadWriteLock"><span class="toc-number">7.</span> <span class="toc-text">共享锁和ReentrantReadWriteLock</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%85%B1%E4%BA%AB%E9%94%81"><span class="toc-number">7.1.</span> <span class="toc-text">获取共享锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E5%85%B1%E4%BA%AB%E9%94%81"><span class="toc-number">7.2.</span> <span class="toc-text">释放共享锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E5%85%B1%E4%BA%AB%E9%94%81"><span class="toc-number">7.3.</span> <span class="toc-text">公平共享锁和非公平共享锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantReadWriteLock%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.4.</span> <span class="toc-text">ReentrantReadWriteLock示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CountDownLatch%E5%8E%9F%E7%90%86%E5%92%8C%E7%A4%BA%E4%BE%8B"><span class="toc-number">8.</span> <span class="toc-text">CountDownLatch原理和示例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CountDownLatch%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">8.1.</span> <span class="toc-text">CountDownLatch的使用示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CyclicBarrier%E5%8E%9F%E7%90%86%E5%92%8C%E7%A4%BA%E4%BE%8B"><span class="toc-number">9.</span> <span class="toc-text">CyclicBarrier原理和示例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CyclicBarrier%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">9.1.</span> <span class="toc-text">CyclicBarrier的使用示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Semaphore%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E7%A4%BA%E4%BE%8B"><span class="toc-number">10.</span> <span class="toc-text">Semaphore信号量的原理和示例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%8E%B7%E5%8F%96%E5%92%8C%E9%87%8A%E6%94%BE"><span class="toc-number">10.1.</span> <span class="toc-text">公平信号量获取和释放</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E5%85%AC%E5%B9%B3%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%8E%B7%E5%8F%96%E5%92%8C%E9%87%8A%E6%94%BE"><span class="toc-number">10.2.</span> <span class="toc-text">非公平信号量获取和释放</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Semaphore%E7%A4%BA%E4%BE%8B"><span class="toc-number">10.3.</span> <span class="toc-text">Semaphore示例</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://pic.hycbook.com/i/hexo/config_imgs/footer_bg.webp')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By narutohyc</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><p><a target="_blank" href="https://hexo.io/" rel="external nofollow noreferrer"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://demo.jerryc.me/" rel="external nofollow noreferrer"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://vercel.com/ " rel="external nofollow noreferrer"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://github.com/" rel="external nofollow noreferrer"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="https://zixiaoyun.com" rel="external nofollow noreferrer"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/图床-薄荷图床-green" title="薄荷图床"></a></p><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=35020502000647" rel="external nofollow noreferrer"><img style="position:relative;top:4px" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.hycbook.com/i//hexo/config_imgs//备案图标.webp" alt="ICP"/>闽公网安备35020502000647号  </a><a href="https://beian.miit.gov.cn/" rel="external nofollow noreferrer" target="_blank">闽ICP备2022013843号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="fa-solid fa-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="fa-solid fa-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="fa-solid fa-arrow-rotate-right"></i></div><div class="rightMenu-item" id="menu-home"><i class="fa-solid fa-house"></i></div></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();" rel="external nofollow noreferrer"><i class="fas fa-comment"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" href="/archives/"><i class="fa-solid fa-archive"></i><span>文章归档</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="fa-solid fa-folder-open"></i><span>文章分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="fa-solid fa-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuNormal"><a class="rightMenu-item menu-link" id="menu-radompage"><i class="fa-solid fa-shoe-prints"></i><span>随便逛逛</span></a><div class="rightMenu-item" id="menu-translate"><i class="fa-solid fa-earth-asia"></i><span>繁简切换</span></div><div class="rightMenu-item" id="menu-darkmode"><i class="fa-solid fa-moon"></i><span>切换模式</span></div></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? '' : ''

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://vercel.hycbook.com',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://vercel.hycbook.com',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'ncn88uooQf0IO2rrGE7Vniwp-gzGzoHsz',
      appKey: 'Yghpzg1QfBMFJ0MxxHubVzKL',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Twikoo' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://vercel.hycbook.com',
        region: '',
        pageSize: 3,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/rightMenu.js"></script><script defer data-pjax src="/js/udf_mouse.js"></script><script defer data-pjax src="/js/udf_js.js"></script><script defer data-pjax src="/zhheo/random.js"></script><script data-pjax src="/js/coin.js"></script><script defer src="https://npm.elemecdn.com/vue@2.6.11"></script><script async src="//at.alicdn.com/t/c/font_3670467_a0sijt8frxo.js"></script><script defer src="/live2d-widget/autoload.js"></script><script defer src="/js/udf_js.js"></script><script defer src="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script>window.$crisp = [];
window.CRISP_WEBSITE_ID = "561b80db-3f0f-45cb-b3b1-aae7355939e6";
(function () {
  d = document;
  s = d.createElement("script");
  s.src = "https://client.crisp.chat/l.js";
  s.async = 1;
  d.getElementsByTagName("head")[0].appendChild(s);
})();
$crisp.push(["safe", true])

if (false) {
  $crisp.push(["do", "chat:hide"])
  $crisp.push(["on", "chat:closed", function() {
    $crisp.push(["do", "chat:hide"])
  }])
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      $crisp.push(["do", "chat:show"])
      $crisp.push(["do", "chat:open"])

    });
  }
  chatBtnFn()
} else {
  if (false) {
    function chatBtnHide () {
      $crisp.push(["do", "chat:hide"])
    }
    function chatBtnShow () {
      $crisp.push(["do", "chat:show"])
    }
  }
}</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="app-refresh" id="app-refresh" style="position: fixed;top: -2.2rem;left: 0;right: 0;z-index: 99999;padding: 0 1rem;font-size: 15px;height: 2.2rem;transition: all 0.3s ease;"><div class="app-refresh-wrap" style=" display: flex;color: #fff;height: 100%;align-items: center;justify-content: center;"><label>✨ 兼一书虫上新啦！ 👉</label><a href="javascript:void(0)" rel="external nofollow noreferrer" onclick="location.reload()"><span style="color: #fff;text-decoration: underline;cursor: pointer;">🍭查看新品🍬</span></a></div></div><script>if ('serviceWorker' in navigator) {
  if (navigator.serviceWorker.controller) {
    navigator.serviceWorker.addEventListener('controllerchange', function() {
      showNotification()
    })
  }
  window.addEventListener('load', function() {
    navigator.serviceWorker.register('/sw.js')
  })
}

function showNotification() {
  if (GLOBAL_CONFIG.Snackbar) {
    var snackbarBg =
      document.documentElement.getAttribute('data-theme') === 'light' ?
      GLOBAL_CONFIG.Snackbar.bgLight :
      GLOBAL_CONFIG.Snackbar.bgDark
    var snackbarPos = GLOBAL_CONFIG.Snackbar.position
    Snackbar.show({
      text: '✨ 兼一书虫上新啦！ 👉',
      backgroundColor: snackbarBg,
      duration: 500000,
      pos: snackbarPos,
      actionText: '🍭查看新品🍬',
      actionTextColor: '#fff',
      onActionClick: function(e) {
        location.reload()
      },
    })
  } else {
    var showBg =
      document.documentElement.getAttribute('data-theme') === 'light' ?
      '#49b1f5' :
      '#1f1f1f'
    var cssText = `top: 0; background: ${showBg};`
    document.getElementById('app-refresh')
      .style.cssText = cssText
  }
}</script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>